// Code generated from GoSugar.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // GoSugar

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type GoSugarParser struct {
	*antlr.BaseParser
}

var GoSugarParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func gosugarParserInit() {
	staticData := &GoSugarParserStaticData
	staticData.LiteralNames = []string{
		"", "'interface'", "'{'", "'}'", "'('", "')'", "'class'", "'as'", "'use'",
		"'must'", "'package'", "'import'", "'[]'", "','", "'['", "']'", "'map'",
		"'func'", "':'", "'->'", "'switch'", "'case'", "'default'", "'!'", "'{}'",
		"'='", "':='", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='",
		"'&='", "'^='", "'|='", "'=='", "'!='", "'>'", "'<'", "'>='", "'<='",
		"'||'", "'&&'", "'+'", "'interface{}'", "'/'", "'%'", "'-'", "'return'",
		"'continue'", "'break'", "'var'", "'if'", "';'", "'else'", "'++'", "'--'",
		"'for'", "'range'", "'foreach'", "'...'", "'*'", "'&'", "'create'",
		"'static'", "", "", "", "'.'", "", "'nil'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "ELLIPSIS", "STAR", "AMPERSAND",
		"CREATE", "STATIC", "IDENTIFIER", "NUMBER", "POSITIVE_INTEGER", "DOT",
		"STRING", "NIL", "WS", "BlockComment", "LineComment", "NEWLINE",
	}
	staticData.RuleNames = []string{
		"program", "programDeclaration", "globalVarStatement", "interfaceDeclaration",
		"interfaceBody", "interfaceMethod", "classDeclaration", "packageDeclaration",
		"importsDeclaration", "createObjectDeclaration", "sliceDeclaration",
		"sliceOrArrayLiteral", "listAccess", "aliasType", "compositionList",
		"mustInterfaceList", "classBody", "classMember", "varType", "fieldDeclaration",
		"methodDeclaration", "anonimousFunctionDeclaration", "returnType", "returnTypeList",
		"returnTypeSingle", "parameterList", "methodBody", "parameter", "block",
		"statement", "switchStatement", "caseBlock", "defaultBlock", "negationExpression",
		"assignment", "assignmentLeftHandSide", "leftHandSide", "assignmentOperator",
		"comparisonOperator", "methodCall", "argumentList", "expression", "concatenatedString",
		"interfaceTypeVerification", "primaryExpression", "directCreateInstance",
		"mapKeyValue", "listLiteral", "operatorExpression", "comparison", "returnOperation",
		"continueOperation", "breakOperation", "varValue", "varStatement", "ifStatement",
		"elseStatement", "incrementOrDecrementStatement", "forStatement", "classicForLoop",
		"rangeForLoop", "conditionForLoop", "infiniteForLoop", "simpleStatement",
		"expressionList", "mapInitialization", "foreachStatement", "typeConversion",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 76, 970, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 1, 0,
		5, 0, 138, 8, 0, 10, 0, 12, 0, 141, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 3, 1, 151, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 4, 1, 4, 5, 4, 161, 8, 4, 10, 4, 12, 4, 164, 9, 4, 1, 4, 1, 4, 1, 5,
		1, 5, 1, 5, 3, 5, 171, 8, 5, 1, 5, 1, 5, 3, 5, 175, 8, 5, 1, 6, 1, 6, 1,
		6, 1, 6, 3, 6, 181, 8, 6, 1, 6, 1, 6, 3, 6, 185, 8, 6, 1, 6, 1, 6, 3, 6,
		189, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		5, 8, 201, 8, 8, 10, 8, 12, 8, 204, 9, 8, 1, 8, 1, 8, 5, 8, 208, 8, 8,
		10, 8, 12, 8, 211, 9, 8, 1, 8, 5, 8, 214, 8, 8, 10, 8, 12, 8, 217, 9, 8,
		1, 8, 5, 8, 220, 8, 8, 10, 8, 12, 8, 223, 9, 8, 1, 8, 5, 8, 226, 8, 8,
		10, 8, 12, 8, 229, 9, 8, 1, 8, 3, 8, 232, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 238, 8, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		5, 10, 248, 8, 10, 10, 10, 12, 10, 251, 9, 10, 3, 10, 253, 8, 10, 1, 10,
		1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 261, 8, 11, 10, 11, 12, 11, 264,
		9, 11, 3, 11, 266, 8, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 5, 12, 275, 8, 12, 10, 12, 12, 12, 278, 9, 12, 1, 13, 1, 13, 1, 14,
		1, 14, 1, 14, 5, 14, 285, 8, 14, 10, 14, 12, 14, 288, 9, 14, 1, 15, 1,
		15, 1, 15, 5, 15, 293, 8, 15, 10, 15, 12, 15, 296, 9, 15, 1, 16, 1, 16,
		5, 16, 300, 8, 16, 10, 16, 12, 16, 303, 9, 16, 1, 16, 1, 16, 1, 17, 1,
		17, 3, 17, 309, 8, 17, 1, 18, 3, 18, 312, 8, 18, 1, 18, 3, 18, 315, 8,
		18, 1, 18, 1, 18, 3, 18, 319, 8, 18, 1, 18, 3, 18, 322, 8, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 327, 8, 18, 1, 18, 3, 18, 330, 8, 18, 1, 18, 1, 18, 3,
		18, 334, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 339, 8, 18, 1, 18, 3, 18, 342,
		8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 351, 8,
		18, 1, 18, 3, 18, 354, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 359, 8, 18, 1,
		19, 1, 19, 1, 19, 1, 20, 3, 20, 365, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		3, 20, 371, 8, 20, 1, 20, 1, 20, 3, 20, 375, 8, 20, 1, 20, 1, 20, 1, 21,
		1, 21, 3, 21, 381, 8, 21, 1, 21, 1, 21, 1, 21, 3, 21, 386, 8, 21, 1, 21,
		1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 396, 8, 22, 1,
		23, 1, 23, 1, 23, 5, 23, 401, 8, 23, 10, 23, 12, 23, 404, 9, 23, 1, 24,
		1, 24, 1, 25, 1, 25, 1, 25, 5, 25, 411, 8, 25, 10, 25, 12, 25, 414, 9,
		25, 1, 26, 1, 26, 5, 26, 418, 8, 26, 10, 26, 12, 26, 421, 9, 26, 1, 26,
		1, 26, 1, 27, 1, 27, 3, 27, 427, 8, 27, 1, 27, 1, 27, 1, 27, 3, 27, 432,
		8, 27, 1, 28, 1, 28, 5, 28, 436, 8, 28, 10, 28, 12, 28, 439, 9, 28, 1,
		28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 456, 8, 29, 1, 30, 1, 30, 1, 30, 1,
		30, 5, 30, 462, 8, 30, 10, 30, 12, 30, 465, 9, 30, 1, 30, 3, 30, 468, 8,
		30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 476, 8, 31, 10, 31,
		12, 31, 479, 9, 31, 1, 32, 1, 32, 1, 32, 5, 32, 484, 8, 32, 10, 32, 12,
		32, 487, 9, 32, 1, 33, 1, 33, 3, 33, 491, 8, 33, 1, 33, 3, 33, 494, 8,
		33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 3, 34, 501, 8, 34, 1, 34, 1, 34,
		1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 511, 8, 35, 1, 36, 3,
		36, 514, 8, 36, 1, 36, 3, 36, 517, 8, 36, 1, 36, 1, 36, 5, 36, 521, 8,
		36, 10, 36, 12, 36, 524, 9, 36, 1, 36, 1, 36, 5, 36, 528, 8, 36, 10, 36,
		12, 36, 531, 9, 36, 1, 36, 3, 36, 534, 8, 36, 1, 36, 3, 36, 537, 8, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 544, 8, 36, 10, 36, 12, 36, 547,
		9, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 555, 8, 36, 10,
		36, 12, 36, 558, 9, 36, 5, 36, 560, 8, 36, 10, 36, 12, 36, 563, 9, 36,
		3, 36, 565, 8, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 3,
		39, 574, 8, 39, 1, 39, 1, 39, 1, 39, 3, 39, 579, 8, 39, 1, 39, 1, 39, 1,
		39, 3, 39, 584, 8, 39, 1, 39, 1, 39, 3, 39, 588, 8, 39, 1, 39, 1, 39, 3,
		39, 592, 8, 39, 3, 39, 594, 8, 39, 1, 40, 1, 40, 1, 40, 5, 40, 599, 8,
		40, 10, 40, 12, 40, 602, 9, 40, 1, 41, 1, 41, 5, 41, 606, 8, 41, 10, 41,
		12, 41, 609, 9, 41, 1, 42, 1, 42, 1, 42, 4, 42, 614, 8, 42, 11, 42, 12,
		42, 615, 1, 43, 3, 43, 619, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 625,
		8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 630, 8, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 3, 43, 637, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 642, 8, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 652, 8, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 659, 8, 43, 1, 43, 3, 43, 662,
		8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 668, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 3, 43, 675, 8, 43, 1, 43, 3, 43, 678, 8, 43, 1, 43, 1,
		43, 3, 43, 682, 8, 43, 3, 43, 684, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 693, 8, 44, 1, 44, 3, 44, 696, 8, 44, 1, 44, 1,
		44, 3, 44, 700, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 721, 8, 44, 1, 45, 3, 45, 724, 8, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 5, 45, 731, 8, 45, 10, 45, 12, 45, 734, 9, 45, 1, 45,
		3, 45, 737, 8, 45, 3, 45, 739, 8, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 751, 8, 47, 10, 47, 12, 47, 754,
		9, 47, 1, 47, 3, 47, 757, 8, 47, 3, 47, 759, 8, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 5, 47, 766, 8, 47, 10, 47, 12, 47, 769, 9, 47, 1, 47, 3,
		47, 772, 8, 47, 3, 47, 774, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 5, 47, 782, 8, 47, 10, 47, 12, 47, 785, 9, 47, 1, 47, 3, 47, 788, 8,
		47, 3, 47, 790, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 797, 8,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 804, 8, 47, 10, 47, 12, 47,
		807, 9, 47, 1, 47, 3, 47, 810, 8, 47, 3, 47, 812, 8, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 3, 47, 819, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 3, 48, 828, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49,
		834, 8, 49, 1, 50, 1, 50, 3, 50, 838, 8, 50, 1, 51, 1, 51, 3, 51, 842,
		8, 51, 1, 52, 1, 52, 3, 52, 846, 8, 52, 1, 53, 1, 53, 1, 53, 3, 53, 851,
		8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 859, 8, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 866, 8, 54, 1, 55, 1, 55, 1, 55,
		1, 55, 3, 55, 872, 8, 55, 1, 55, 1, 55, 1, 55, 3, 55, 877, 8, 55, 1, 56,
		1, 56, 1, 56, 3, 56, 882, 8, 56, 1, 57, 3, 57, 885, 8, 57, 1, 57, 3, 57,
		888, 8, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3,
		58, 898, 8, 58, 1, 58, 1, 58, 1, 59, 3, 59, 903, 8, 59, 1, 59, 1, 59, 3,
		59, 907, 8, 59, 1, 59, 1, 59, 3, 59, 911, 8, 59, 1, 60, 1, 60, 1, 60, 3,
		60, 916, 8, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 63,
		1, 63, 1, 63, 3, 63, 928, 8, 63, 1, 64, 1, 64, 1, 64, 5, 64, 933, 8, 64,
		10, 64, 12, 64, 936, 9, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 943,
		8, 65, 10, 65, 12, 65, 946, 9, 65, 1, 65, 3, 65, 949, 8, 65, 3, 65, 951,
		8, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 961,
		8, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 0, 0, 68,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 0,
		6, 1, 0, 25, 36, 1, 0, 37, 44, 2, 0, 67, 67, 71, 71, 2, 0, 47, 48, 63,
		63, 2, 0, 45, 45, 49, 49, 1, 0, 57, 58, 1086, 0, 139, 1, 0, 0, 0, 2, 150,
		1, 0, 0, 0, 4, 152, 1, 0, 0, 0, 6, 154, 1, 0, 0, 0, 8, 158, 1, 0, 0, 0,
		10, 167, 1, 0, 0, 0, 12, 176, 1, 0, 0, 0, 14, 192, 1, 0, 0, 0, 16, 231,
		1, 0, 0, 0, 18, 233, 1, 0, 0, 0, 20, 241, 1, 0, 0, 0, 22, 256, 1, 0, 0,
		0, 24, 269, 1, 0, 0, 0, 26, 279, 1, 0, 0, 0, 28, 281, 1, 0, 0, 0, 30, 289,
		1, 0, 0, 0, 32, 297, 1, 0, 0, 0, 34, 308, 1, 0, 0, 0, 36, 358, 1, 0, 0,
		0, 38, 360, 1, 0, 0, 0, 40, 364, 1, 0, 0, 0, 42, 378, 1, 0, 0, 0, 44, 395,
		1, 0, 0, 0, 46, 397, 1, 0, 0, 0, 48, 405, 1, 0, 0, 0, 50, 407, 1, 0, 0,
		0, 52, 415, 1, 0, 0, 0, 54, 431, 1, 0, 0, 0, 56, 433, 1, 0, 0, 0, 58, 455,
		1, 0, 0, 0, 60, 457, 1, 0, 0, 0, 62, 471, 1, 0, 0, 0, 64, 480, 1, 0, 0,
		0, 66, 488, 1, 0, 0, 0, 68, 497, 1, 0, 0, 0, 70, 510, 1, 0, 0, 0, 72, 564,
		1, 0, 0, 0, 74, 566, 1, 0, 0, 0, 76, 568, 1, 0, 0, 0, 78, 593, 1, 0, 0,
		0, 80, 595, 1, 0, 0, 0, 82, 603, 1, 0, 0, 0, 84, 610, 1, 0, 0, 0, 86, 683,
		1, 0, 0, 0, 88, 720, 1, 0, 0, 0, 90, 723, 1, 0, 0, 0, 92, 742, 1, 0, 0,
		0, 94, 818, 1, 0, 0, 0, 96, 827, 1, 0, 0, 0, 98, 829, 1, 0, 0, 0, 100,
		835, 1, 0, 0, 0, 102, 839, 1, 0, 0, 0, 104, 843, 1, 0, 0, 0, 106, 850,
		1, 0, 0, 0, 108, 865, 1, 0, 0, 0, 110, 867, 1, 0, 0, 0, 112, 878, 1, 0,
		0, 0, 114, 884, 1, 0, 0, 0, 116, 892, 1, 0, 0, 0, 118, 902, 1, 0, 0, 0,
		120, 915, 1, 0, 0, 0, 122, 920, 1, 0, 0, 0, 124, 922, 1, 0, 0, 0, 126,
		927, 1, 0, 0, 0, 128, 929, 1, 0, 0, 0, 130, 937, 1, 0, 0, 0, 132, 954,
		1, 0, 0, 0, 134, 964, 1, 0, 0, 0, 136, 138, 3, 2, 1, 0, 137, 136, 1, 0,
		0, 0, 138, 141, 1, 0, 0, 0, 139, 137, 1, 0, 0, 0, 139, 140, 1, 0, 0, 0,
		140, 142, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 142, 143, 5, 0, 0, 1, 143,
		1, 1, 0, 0, 0, 144, 151, 3, 16, 8, 0, 145, 151, 3, 4, 2, 0, 146, 151, 3,
		6, 3, 0, 147, 151, 3, 12, 6, 0, 148, 151, 3, 14, 7, 0, 149, 151, 3, 40,
		20, 0, 150, 144, 1, 0, 0, 0, 150, 145, 1, 0, 0, 0, 150, 146, 1, 0, 0, 0,
		150, 147, 1, 0, 0, 0, 150, 148, 1, 0, 0, 0, 150, 149, 1, 0, 0, 0, 151,
		3, 1, 0, 0, 0, 152, 153, 3, 108, 54, 0, 153, 5, 1, 0, 0, 0, 154, 155, 5,
		1, 0, 0, 155, 156, 5, 67, 0, 0, 156, 157, 3, 8, 4, 0, 157, 7, 1, 0, 0,
		0, 158, 162, 5, 2, 0, 0, 159, 161, 3, 10, 5, 0, 160, 159, 1, 0, 0, 0, 161,
		164, 1, 0, 0, 0, 162, 160, 1, 0, 0, 0, 162, 163, 1, 0, 0, 0, 163, 165,
		1, 0, 0, 0, 164, 162, 1, 0, 0, 0, 165, 166, 5, 3, 0, 0, 166, 9, 1, 0, 0,
		0, 167, 168, 5, 67, 0, 0, 168, 170, 5, 4, 0, 0, 169, 171, 3, 50, 25, 0,
		170, 169, 1, 0, 0, 0, 170, 171, 1, 0, 0, 0, 171, 172, 1, 0, 0, 0, 172,
		174, 5, 5, 0, 0, 173, 175, 3, 44, 22, 0, 174, 173, 1, 0, 0, 0, 174, 175,
		1, 0, 0, 0, 175, 11, 1, 0, 0, 0, 176, 177, 5, 6, 0, 0, 177, 180, 5, 67,
		0, 0, 178, 179, 5, 7, 0, 0, 179, 181, 3, 26, 13, 0, 180, 178, 1, 0, 0,
		0, 180, 181, 1, 0, 0, 0, 181, 184, 1, 0, 0, 0, 182, 183, 5, 8, 0, 0, 183,
		185, 3, 28, 14, 0, 184, 182, 1, 0, 0, 0, 184, 185, 1, 0, 0, 0, 185, 188,
		1, 0, 0, 0, 186, 187, 5, 9, 0, 0, 187, 189, 3, 30, 15, 0, 188, 186, 1,
		0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190, 191, 3, 32, 16,
		0, 191, 13, 1, 0, 0, 0, 192, 193, 5, 10, 0, 0, 193, 194, 5, 67, 0, 0, 194,
		15, 1, 0, 0, 0, 195, 196, 5, 11, 0, 0, 196, 232, 5, 71, 0, 0, 197, 198,
		5, 11, 0, 0, 198, 202, 5, 4, 0, 0, 199, 201, 5, 73, 0, 0, 200, 199, 1,
		0, 0, 0, 201, 204, 1, 0, 0, 0, 202, 200, 1, 0, 0, 0, 202, 203, 1, 0, 0,
		0, 203, 205, 1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 205, 227, 5, 71, 0, 0, 206,
		208, 5, 73, 0, 0, 207, 206, 1, 0, 0, 0, 208, 211, 1, 0, 0, 0, 209, 207,
		1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210, 215, 1, 0, 0, 0, 211, 209, 1, 0,
		0, 0, 212, 214, 5, 76, 0, 0, 213, 212, 1, 0, 0, 0, 214, 217, 1, 0, 0, 0,
		215, 213, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216, 221, 1, 0, 0, 0, 217,
		215, 1, 0, 0, 0, 218, 220, 5, 73, 0, 0, 219, 218, 1, 0, 0, 0, 220, 223,
		1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 221, 222, 1, 0, 0, 0, 222, 224, 1, 0,
		0, 0, 223, 221, 1, 0, 0, 0, 224, 226, 5, 71, 0, 0, 225, 209, 1, 0, 0, 0,
		226, 229, 1, 0, 0, 0, 227, 225, 1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228,
		230, 1, 0, 0, 0, 229, 227, 1, 0, 0, 0, 230, 232, 5, 5, 0, 0, 231, 195,
		1, 0, 0, 0, 231, 197, 1, 0, 0, 0, 232, 17, 1, 0, 0, 0, 233, 234, 5, 65,
		0, 0, 234, 235, 5, 67, 0, 0, 235, 237, 5, 4, 0, 0, 236, 238, 3, 80, 40,
		0, 237, 236, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238, 239, 1, 0, 0, 0, 239,
		240, 5, 5, 0, 0, 240, 19, 1, 0, 0, 0, 241, 242, 5, 12, 0, 0, 242, 243,
		5, 67, 0, 0, 243, 252, 5, 2, 0, 0, 244, 249, 3, 88, 44, 0, 245, 246, 5,
		13, 0, 0, 246, 248, 3, 88, 44, 0, 247, 245, 1, 0, 0, 0, 248, 251, 1, 0,
		0, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 253, 1, 0, 0, 0,
		251, 249, 1, 0, 0, 0, 252, 244, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253,
		254, 1, 0, 0, 0, 254, 255, 5, 3, 0, 0, 255, 21, 1, 0, 0, 0, 256, 265, 5,
		14, 0, 0, 257, 262, 3, 88, 44, 0, 258, 259, 5, 13, 0, 0, 259, 261, 3, 88,
		44, 0, 260, 258, 1, 0, 0, 0, 261, 264, 1, 0, 0, 0, 262, 260, 1, 0, 0, 0,
		262, 263, 1, 0, 0, 0, 263, 266, 1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 265,
		257, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 268,
		5, 15, 0, 0, 268, 23, 1, 0, 0, 0, 269, 276, 3, 72, 36, 0, 270, 271, 5,
		14, 0, 0, 271, 272, 3, 82, 41, 0, 272, 273, 5, 15, 0, 0, 273, 275, 1, 0,
		0, 0, 274, 270, 1, 0, 0, 0, 275, 278, 1, 0, 0, 0, 276, 274, 1, 0, 0, 0,
		276, 277, 1, 0, 0, 0, 277, 25, 1, 0, 0, 0, 278, 276, 1, 0, 0, 0, 279, 280,
		3, 36, 18, 0, 280, 27, 1, 0, 0, 0, 281, 286, 3, 72, 36, 0, 282, 283, 5,
		13, 0, 0, 283, 285, 3, 72, 36, 0, 284, 282, 1, 0, 0, 0, 285, 288, 1, 0,
		0, 0, 286, 284, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 29, 1, 0, 0, 0,
		288, 286, 1, 0, 0, 0, 289, 294, 5, 67, 0, 0, 290, 291, 5, 13, 0, 0, 291,
		293, 5, 67, 0, 0, 292, 290, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294, 292,
		1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 31, 1, 0, 0, 0, 296, 294, 1, 0,
		0, 0, 297, 301, 5, 2, 0, 0, 298, 300, 3, 34, 17, 0, 299, 298, 1, 0, 0,
		0, 300, 303, 1, 0, 0, 0, 301, 299, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0, 302,
		304, 1, 0, 0, 0, 303, 301, 1, 0, 0, 0, 304, 305, 5, 3, 0, 0, 305, 33, 1,
		0, 0, 0, 306, 309, 3, 38, 19, 0, 307, 309, 3, 40, 20, 0, 308, 306, 1, 0,
		0, 0, 308, 307, 1, 0, 0, 0, 309, 35, 1, 0, 0, 0, 310, 312, 5, 63, 0, 0,
		311, 310, 1, 0, 0, 0, 311, 312, 1, 0, 0, 0, 312, 314, 1, 0, 0, 0, 313,
		315, 5, 64, 0, 0, 314, 313, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 316,
		1, 0, 0, 0, 316, 359, 5, 67, 0, 0, 317, 319, 5, 63, 0, 0, 318, 317, 1,
		0, 0, 0, 318, 319, 1, 0, 0, 0, 319, 321, 1, 0, 0, 0, 320, 322, 5, 64, 0,
		0, 321, 320, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 1, 0, 0, 0, 323,
		324, 5, 12, 0, 0, 324, 359, 3, 36, 18, 0, 325, 327, 5, 63, 0, 0, 326, 325,
		1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 329, 1, 0, 0, 0, 328, 330, 5, 64,
		0, 0, 329, 328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0,
		331, 333, 5, 14, 0, 0, 332, 334, 5, 68, 0, 0, 333, 332, 1, 0, 0, 0, 333,
		334, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 336, 5, 15, 0, 0, 336, 359,
		3, 36, 18, 0, 337, 339, 5, 63, 0, 0, 338, 337, 1, 0, 0, 0, 338, 339, 1,
		0, 0, 0, 339, 341, 1, 0, 0, 0, 340, 342, 5, 64, 0, 0, 341, 340, 1, 0, 0,
		0, 341, 342, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344, 5, 16, 0, 0, 344,
		345, 5, 14, 0, 0, 345, 346, 3, 36, 18, 0, 346, 347, 5, 15, 0, 0, 347, 348,
		3, 36, 18, 0, 348, 359, 1, 0, 0, 0, 349, 351, 5, 63, 0, 0, 350, 349, 1,
		0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 353, 1, 0, 0, 0, 352, 354, 5, 64, 0,
		0, 353, 352, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355,
		356, 5, 67, 0, 0, 356, 357, 5, 70, 0, 0, 357, 359, 3, 36, 18, 0, 358, 311,
		1, 0, 0, 0, 358, 318, 1, 0, 0, 0, 358, 326, 1, 0, 0, 0, 358, 338, 1, 0,
		0, 0, 358, 350, 1, 0, 0, 0, 359, 37, 1, 0, 0, 0, 360, 361, 5, 67, 0, 0,
		361, 362, 3, 36, 18, 0, 362, 39, 1, 0, 0, 0, 363, 365, 5, 66, 0, 0, 364,
		363, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 367,
		5, 17, 0, 0, 367, 368, 5, 67, 0, 0, 368, 370, 5, 4, 0, 0, 369, 371, 3,
		50, 25, 0, 370, 369, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 372, 1, 0,
		0, 0, 372, 374, 5, 5, 0, 0, 373, 375, 3, 44, 22, 0, 374, 373, 1, 0, 0,
		0, 374, 375, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0, 376, 377, 3, 52, 26, 0,
		377, 41, 1, 0, 0, 0, 378, 380, 5, 4, 0, 0, 379, 381, 3, 50, 25, 0, 380,
		379, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 385,
		5, 5, 0, 0, 383, 384, 5, 18, 0, 0, 384, 386, 3, 44, 22, 0, 385, 383, 1,
		0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 388, 5, 19, 0,
		0, 388, 389, 3, 52, 26, 0, 389, 43, 1, 0, 0, 0, 390, 391, 5, 4, 0, 0, 391,
		392, 3, 46, 23, 0, 392, 393, 5, 5, 0, 0, 393, 396, 1, 0, 0, 0, 394, 396,
		3, 36, 18, 0, 395, 390, 1, 0, 0, 0, 395, 394, 1, 0, 0, 0, 396, 45, 1, 0,
		0, 0, 397, 402, 3, 48, 24, 0, 398, 399, 5, 13, 0, 0, 399, 401, 3, 48, 24,
		0, 400, 398, 1, 0, 0, 0, 401, 404, 1, 0, 0, 0, 402, 400, 1, 0, 0, 0, 402,
		403, 1, 0, 0, 0, 403, 47, 1, 0, 0, 0, 404, 402, 1, 0, 0, 0, 405, 406, 3,
		36, 18, 0, 406, 49, 1, 0, 0, 0, 407, 412, 3, 54, 27, 0, 408, 409, 5, 13,
		0, 0, 409, 411, 3, 54, 27, 0, 410, 408, 1, 0, 0, 0, 411, 414, 1, 0, 0,
		0, 412, 410, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 51, 1, 0, 0, 0, 414,
		412, 1, 0, 0, 0, 415, 419, 5, 2, 0, 0, 416, 418, 3, 58, 29, 0, 417, 416,
		1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 419, 420, 1, 0,
		0, 0, 420, 422, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 422, 423, 5, 3, 0, 0,
		423, 53, 1, 0, 0, 0, 424, 426, 5, 67, 0, 0, 425, 427, 3, 36, 18, 0, 426,
		425, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 432, 1, 0, 0, 0, 428, 429,
		5, 67, 0, 0, 429, 430, 5, 62, 0, 0, 430, 432, 3, 36, 18, 0, 431, 424, 1,
		0, 0, 0, 431, 428, 1, 0, 0, 0, 432, 55, 1, 0, 0, 0, 433, 437, 5, 2, 0,
		0, 434, 436, 3, 58, 29, 0, 435, 434, 1, 0, 0, 0, 436, 439, 1, 0, 0, 0,
		437, 435, 1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 440, 1, 0, 0, 0, 439,
		437, 1, 0, 0, 0, 440, 441, 5, 3, 0, 0, 441, 57, 1, 0, 0, 0, 442, 456, 3,
		68, 34, 0, 443, 456, 3, 78, 39, 0, 444, 456, 3, 100, 50, 0, 445, 456, 3,
		102, 51, 0, 446, 456, 3, 104, 52, 0, 447, 456, 3, 108, 54, 0, 448, 456,
		3, 94, 47, 0, 449, 456, 3, 110, 55, 0, 450, 456, 3, 112, 56, 0, 451, 456,
		3, 116, 58, 0, 452, 456, 3, 132, 66, 0, 453, 456, 3, 114, 57, 0, 454, 456,
		3, 60, 30, 0, 455, 442, 1, 0, 0, 0, 455, 443, 1, 0, 0, 0, 455, 444, 1,
		0, 0, 0, 455, 445, 1, 0, 0, 0, 455, 446, 1, 0, 0, 0, 455, 447, 1, 0, 0,
		0, 455, 448, 1, 0, 0, 0, 455, 449, 1, 0, 0, 0, 455, 450, 1, 0, 0, 0, 455,
		451, 1, 0, 0, 0, 455, 452, 1, 0, 0, 0, 455, 453, 1, 0, 0, 0, 455, 454,
		1, 0, 0, 0, 456, 59, 1, 0, 0, 0, 457, 458, 5, 20, 0, 0, 458, 459, 3, 82,
		41, 0, 459, 463, 5, 2, 0, 0, 460, 462, 3, 62, 31, 0, 461, 460, 1, 0, 0,
		0, 462, 465, 1, 0, 0, 0, 463, 461, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464,
		467, 1, 0, 0, 0, 465, 463, 1, 0, 0, 0, 466, 468, 3, 64, 32, 0, 467, 466,
		1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 469, 1, 0, 0, 0, 469, 470, 5, 3,
		0, 0, 470, 61, 1, 0, 0, 0, 471, 472, 5, 21, 0, 0, 472, 473, 3, 128, 64,
		0, 473, 477, 5, 18, 0, 0, 474, 476, 3, 58, 29, 0, 475, 474, 1, 0, 0, 0,
		476, 479, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478,
		63, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 480, 481, 5, 22, 0, 0, 481, 485,
		5, 18, 0, 0, 482, 484, 3, 58, 29, 0, 483, 482, 1, 0, 0, 0, 484, 487, 1,
		0, 0, 0, 485, 483, 1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 65, 1, 0, 0,
		0, 487, 485, 1, 0, 0, 0, 488, 490, 5, 23, 0, 0, 489, 491, 5, 63, 0, 0,
		490, 489, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 493, 1, 0, 0, 0, 492,
		494, 5, 64, 0, 0, 493, 492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 495,
		1, 0, 0, 0, 495, 496, 3, 82, 41, 0, 496, 67, 1, 0, 0, 0, 497, 500, 3, 70,
		35, 0, 498, 499, 5, 13, 0, 0, 499, 501, 3, 70, 35, 0, 500, 498, 1, 0, 0,
		0, 500, 501, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 503, 3, 74, 37, 0,
		503, 504, 3, 82, 41, 0, 504, 69, 1, 0, 0, 0, 505, 506, 3, 72, 36, 0, 506,
		507, 5, 13, 0, 0, 507, 508, 3, 72, 36, 0, 508, 511, 1, 0, 0, 0, 509, 511,
		3, 24, 12, 0, 510, 505, 1, 0, 0, 0, 510, 509, 1, 0, 0, 0, 511, 71, 1, 0,
		0, 0, 512, 514, 5, 63, 0, 0, 513, 512, 1, 0, 0, 0, 513, 514, 1, 0, 0, 0,
		514, 516, 1, 0, 0, 0, 515, 517, 5, 64, 0, 0, 516, 515, 1, 0, 0, 0, 516,
		517, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 522, 5, 67, 0, 0, 519, 521,
		5, 24, 0, 0, 520, 519, 1, 0, 0, 0, 521, 524, 1, 0, 0, 0, 522, 520, 1, 0,
		0, 0, 522, 523, 1, 0, 0, 0, 523, 529, 1, 0, 0, 0, 524, 522, 1, 0, 0, 0,
		525, 526, 5, 70, 0, 0, 526, 528, 5, 67, 0, 0, 527, 525, 1, 0, 0, 0, 528,
		531, 1, 0, 0, 0, 529, 527, 1, 0, 0, 0, 529, 530, 1, 0, 0, 0, 530, 565,
		1, 0, 0, 0, 531, 529, 1, 0, 0, 0, 532, 534, 5, 63, 0, 0, 533, 532, 1, 0,
		0, 0, 533, 534, 1, 0, 0, 0, 534, 536, 1, 0, 0, 0, 535, 537, 5, 64, 0, 0,
		536, 535, 1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538,
		545, 5, 67, 0, 0, 539, 540, 5, 14, 0, 0, 540, 541, 3, 82, 41, 0, 541, 542,
		5, 15, 0, 0, 542, 544, 1, 0, 0, 0, 543, 539, 1, 0, 0, 0, 544, 547, 1, 0,
		0, 0, 545, 543, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 561, 1, 0, 0, 0,
		547, 545, 1, 0, 0, 0, 548, 549, 5, 70, 0, 0, 549, 556, 5, 67, 0, 0, 550,
		551, 5, 14, 0, 0, 551, 552, 3, 82, 41, 0, 552, 553, 5, 15, 0, 0, 553, 555,
		1, 0, 0, 0, 554, 550, 1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556, 554, 1, 0,
		0, 0, 556, 557, 1, 0, 0, 0, 557, 560, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0,
		559, 548, 1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0, 561,
		562, 1, 0, 0, 0, 562, 565, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 564, 513,
		1, 0, 0, 0, 564, 533, 1, 0, 0, 0, 565, 73, 1, 0, 0, 0, 566, 567, 7, 0,
		0, 0, 567, 75, 1, 0, 0, 0, 568, 569, 7, 1, 0, 0, 569, 77, 1, 0, 0, 0, 570,
		571, 5, 67, 0, 0, 571, 573, 5, 4, 0, 0, 572, 574, 3, 80, 40, 0, 573, 572,
		1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 578, 5, 5,
		0, 0, 576, 577, 5, 70, 0, 0, 577, 579, 3, 78, 39, 0, 578, 576, 1, 0, 0,
		0, 578, 579, 1, 0, 0, 0, 579, 594, 1, 0, 0, 0, 580, 581, 3, 72, 36, 0,
		581, 583, 5, 4, 0, 0, 582, 584, 3, 80, 40, 0, 583, 582, 1, 0, 0, 0, 583,
		584, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 587, 5, 5, 0, 0, 586, 588,
		5, 13, 0, 0, 587, 586, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 591, 1, 0,
		0, 0, 589, 590, 5, 70, 0, 0, 590, 592, 3, 78, 39, 0, 591, 589, 1, 0, 0,
		0, 591, 592, 1, 0, 0, 0, 592, 594, 1, 0, 0, 0, 593, 570, 1, 0, 0, 0, 593,
		580, 1, 0, 0, 0, 594, 79, 1, 0, 0, 0, 595, 600, 3, 82, 41, 0, 596, 597,
		5, 13, 0, 0, 597, 599, 3, 82, 41, 0, 598, 596, 1, 0, 0, 0, 599, 602, 1,
		0, 0, 0, 600, 598, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 81, 1, 0, 0,
		0, 602, 600, 1, 0, 0, 0, 603, 607, 3, 88, 44, 0, 604, 606, 3, 96, 48, 0,
		605, 604, 1, 0, 0, 0, 606, 609, 1, 0, 0, 0, 607, 605, 1, 0, 0, 0, 607,
		608, 1, 0, 0, 0, 608, 83, 1, 0, 0, 0, 609, 607, 1, 0, 0, 0, 610, 613, 5,
		71, 0, 0, 611, 612, 5, 45, 0, 0, 612, 614, 5, 71, 0, 0, 613, 611, 1, 0,
		0, 0, 614, 615, 1, 0, 0, 0, 615, 613, 1, 0, 0, 0, 615, 616, 1, 0, 0, 0,
		616, 85, 1, 0, 0, 0, 617, 619, 5, 63, 0, 0, 618, 617, 1, 0, 0, 0, 618,
		619, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 621, 5, 67, 0, 0, 621, 622,
		5, 70, 0, 0, 622, 624, 5, 4, 0, 0, 623, 625, 5, 63, 0, 0, 624, 623, 1,
		0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626, 629, 5, 67, 0,
		0, 627, 628, 5, 70, 0, 0, 628, 630, 5, 67, 0, 0, 629, 627, 1, 0, 0, 0,
		629, 630, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 684, 5, 5, 0, 0, 632,
		633, 3, 78, 39, 0, 633, 634, 5, 70, 0, 0, 634, 636, 5, 4, 0, 0, 635, 637,
		5, 63, 0, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 638, 1, 0,
		0, 0, 638, 641, 5, 67, 0, 0, 639, 640, 5, 70, 0, 0, 640, 642, 5, 67, 0,
		0, 641, 639, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643,
		644, 5, 5, 0, 0, 644, 684, 1, 0, 0, 0, 645, 646, 5, 46, 0, 0, 646, 647,
		5, 4, 0, 0, 647, 651, 5, 67, 0, 0, 648, 649, 5, 70, 0, 0, 649, 652, 5,
		67, 0, 0, 650, 652, 3, 78, 39, 0, 651, 648, 1, 0, 0, 0, 651, 650, 1, 0,
		0, 0, 651, 652, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 658, 5, 5, 0, 0,
		654, 655, 5, 70, 0, 0, 655, 656, 5, 4, 0, 0, 656, 657, 5, 67, 0, 0, 657,
		659, 5, 5, 0, 0, 658, 654, 1, 0, 0, 0, 658, 659, 1, 0, 0, 0, 659, 684,
		1, 0, 0, 0, 660, 662, 5, 63, 0, 0, 661, 660, 1, 0, 0, 0, 661, 662, 1, 0,
		0, 0, 662, 663, 1, 0, 0, 0, 663, 664, 5, 67, 0, 0, 664, 667, 5, 70, 0,
		0, 665, 666, 5, 67, 0, 0, 666, 668, 5, 70, 0, 0, 667, 665, 1, 0, 0, 0,
		667, 668, 1, 0, 0, 0, 668, 677, 1, 0, 0, 0, 669, 670, 5, 4, 0, 0, 670,
		674, 5, 67, 0, 0, 671, 672, 5, 70, 0, 0, 672, 675, 5, 67, 0, 0, 673, 675,
		3, 78, 39, 0, 674, 671, 1, 0, 0, 0, 674, 673, 1, 0, 0, 0, 674, 675, 1,
		0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 678, 5, 5, 0, 0, 677, 669, 1, 0, 0,
		0, 677, 678, 1, 0, 0, 0, 678, 681, 1, 0, 0, 0, 679, 680, 5, 70, 0, 0, 680,
		682, 3, 78, 39, 0, 681, 679, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 684,
		1, 0, 0, 0, 683, 618, 1, 0, 0, 0, 683, 632, 1, 0, 0, 0, 683, 645, 1, 0,
		0, 0, 683, 661, 1, 0, 0, 0, 684, 87, 1, 0, 0, 0, 685, 721, 3, 18, 9, 0,
		686, 721, 3, 20, 10, 0, 687, 721, 3, 130, 65, 0, 688, 721, 3, 22, 11, 0,
		689, 692, 3, 78, 39, 0, 690, 691, 5, 70, 0, 0, 691, 693, 3, 78, 39, 0,
		692, 690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 721, 1, 0, 0, 0, 694,
		696, 5, 63, 0, 0, 695, 694, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697,
		1, 0, 0, 0, 697, 721, 5, 67, 0, 0, 698, 700, 5, 64, 0, 0, 699, 698, 1,
		0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 721, 5, 67, 0,
		0, 702, 721, 3, 84, 42, 0, 703, 721, 5, 72, 0, 0, 704, 721, 5, 71, 0, 0,
		705, 721, 5, 68, 0, 0, 706, 721, 3, 72, 36, 0, 707, 721, 3, 94, 47, 0,
		708, 721, 3, 66, 33, 0, 709, 710, 5, 4, 0, 0, 710, 711, 3, 82, 41, 0, 711,
		712, 5, 5, 0, 0, 712, 721, 1, 0, 0, 0, 713, 721, 3, 24, 12, 0, 714, 721,
		3, 42, 21, 0, 715, 721, 3, 114, 57, 0, 716, 721, 3, 134, 67, 0, 717, 721,
		3, 36, 18, 0, 718, 721, 3, 86, 43, 0, 719, 721, 3, 90, 45, 0, 720, 685,
		1, 0, 0, 0, 720, 686, 1, 0, 0, 0, 720, 687, 1, 0, 0, 0, 720, 688, 1, 0,
		0, 0, 720, 689, 1, 0, 0, 0, 720, 695, 1, 0, 0, 0, 720, 699, 1, 0, 0, 0,
		720, 702, 1, 0, 0, 0, 720, 703, 1, 0, 0, 0, 720, 704, 1, 0, 0, 0, 720,
		705, 1, 0, 0, 0, 720, 706, 1, 0, 0, 0, 720, 707, 1, 0, 0, 0, 720, 708,
		1, 0, 0, 0, 720, 709, 1, 0, 0, 0, 720, 713, 1, 0, 0, 0, 720, 714, 1, 0,
		0, 0, 720, 715, 1, 0, 0, 0, 720, 716, 1, 0, 0, 0, 720, 717, 1, 0, 0, 0,
		720, 718, 1, 0, 0, 0, 720, 719, 1, 0, 0, 0, 721, 89, 1, 0, 0, 0, 722, 724,
		5, 64, 0, 0, 723, 722, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 725, 1, 0,
		0, 0, 725, 726, 3, 36, 18, 0, 726, 738, 5, 2, 0, 0, 727, 732, 3, 92, 46,
		0, 728, 729, 5, 13, 0, 0, 729, 731, 3, 92, 46, 0, 730, 728, 1, 0, 0, 0,
		731, 734, 1, 0, 0, 0, 732, 730, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733,
		736, 1, 0, 0, 0, 734, 732, 1, 0, 0, 0, 735, 737, 5, 13, 0, 0, 736, 735,
		1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 739, 1, 0, 0, 0, 738, 727, 1, 0,
		0, 0, 738, 739, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 741, 5, 3, 0, 0,
		741, 91, 1, 0, 0, 0, 742, 743, 7, 2, 0, 0, 743, 744, 5, 18, 0, 0, 744,
		745, 3, 82, 41, 0, 745, 93, 1, 0, 0, 0, 746, 758, 5, 2, 0, 0, 747, 752,
		3, 92, 46, 0, 748, 749, 5, 13, 0, 0, 749, 751, 3, 92, 46, 0, 750, 748,
		1, 0, 0, 0, 751, 754, 1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 752, 753, 1, 0,
		0, 0, 753, 756, 1, 0, 0, 0, 754, 752, 1, 0, 0, 0, 755, 757, 5, 13, 0, 0,
		756, 755, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 759, 1, 0, 0, 0, 758,
		747, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 819,
		5, 3, 0, 0, 761, 773, 5, 2, 0, 0, 762, 767, 3, 82, 41, 0, 763, 764, 5,
		13, 0, 0, 764, 766, 3, 82, 41, 0, 765, 763, 1, 0, 0, 0, 766, 769, 1, 0,
		0, 0, 767, 765, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 771, 1, 0, 0, 0,
		769, 767, 1, 0, 0, 0, 770, 772, 5, 13, 0, 0, 771, 770, 1, 0, 0, 0, 771,
		772, 1, 0, 0, 0, 772, 774, 1, 0, 0, 0, 773, 762, 1, 0, 0, 0, 773, 774,
		1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 819, 5, 3, 0, 0, 776, 777, 3, 36,
		18, 0, 777, 789, 5, 2, 0, 0, 778, 783, 3, 82, 41, 0, 779, 780, 5, 13, 0,
		0, 780, 782, 3, 82, 41, 0, 781, 779, 1, 0, 0, 0, 782, 785, 1, 0, 0, 0,
		783, 781, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 787, 1, 0, 0, 0, 785,
		783, 1, 0, 0, 0, 786, 788, 5, 13, 0, 0, 787, 786, 1, 0, 0, 0, 787, 788,
		1, 0, 0, 0, 788, 790, 1, 0, 0, 0, 789, 778, 1, 0, 0, 0, 789, 790, 1, 0,
		0, 0, 790, 791, 1, 0, 0, 0, 791, 792, 5, 3, 0, 0, 792, 819, 1, 0, 0, 0,
		793, 794, 3, 36, 18, 0, 794, 796, 5, 14, 0, 0, 795, 797, 5, 68, 0, 0, 796,
		795, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 799,
		5, 15, 0, 0, 799, 811, 5, 2, 0, 0, 800, 805, 3, 82, 41, 0, 801, 802, 5,
		13, 0, 0, 802, 804, 3, 82, 41, 0, 803, 801, 1, 0, 0, 0, 804, 807, 1, 0,
		0, 0, 805, 803, 1, 0, 0, 0, 805, 806, 1, 0, 0, 0, 806, 809, 1, 0, 0, 0,
		807, 805, 1, 0, 0, 0, 808, 810, 5, 13, 0, 0, 809, 808, 1, 0, 0, 0, 809,
		810, 1, 0, 0, 0, 810, 812, 1, 0, 0, 0, 811, 800, 1, 0, 0, 0, 811, 812,
		1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 814, 5, 3, 0, 0, 814, 819, 1, 0,
		0, 0, 815, 816, 3, 36, 18, 0, 816, 817, 5, 24, 0, 0, 817, 819, 1, 0, 0,
		0, 818, 746, 1, 0, 0, 0, 818, 761, 1, 0, 0, 0, 818, 776, 1, 0, 0, 0, 818,
		793, 1, 0, 0, 0, 818, 815, 1, 0, 0, 0, 819, 95, 1, 0, 0, 0, 820, 821, 7,
		3, 0, 0, 821, 828, 3, 88, 44, 0, 822, 823, 7, 4, 0, 0, 823, 828, 3, 88,
		44, 0, 824, 825, 3, 76, 38, 0, 825, 826, 3, 88, 44, 0, 826, 828, 1, 0,
		0, 0, 827, 820, 1, 0, 0, 0, 827, 822, 1, 0, 0, 0, 827, 824, 1, 0, 0, 0,
		828, 97, 1, 0, 0, 0, 829, 833, 3, 88, 44, 0, 830, 831, 3, 76, 38, 0, 831,
		832, 3, 98, 49, 0, 832, 834, 1, 0, 0, 0, 833, 830, 1, 0, 0, 0, 833, 834,
		1, 0, 0, 0, 834, 99, 1, 0, 0, 0, 835, 837, 5, 50, 0, 0, 836, 838, 3, 80,
		40, 0, 837, 836, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838, 101, 1, 0, 0, 0,
		839, 841, 5, 51, 0, 0, 840, 842, 5, 67, 0, 0, 841, 840, 1, 0, 0, 0, 841,
		842, 1, 0, 0, 0, 842, 103, 1, 0, 0, 0, 843, 845, 5, 52, 0, 0, 844, 846,
		5, 67, 0, 0, 845, 844, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0, 846, 105, 1, 0,
		0, 0, 847, 851, 3, 94, 47, 0, 848, 851, 3, 82, 41, 0, 849, 851, 3, 130,
		65, 0, 850, 847, 1, 0, 0, 0, 850, 848, 1, 0, 0, 0, 850, 849, 1, 0, 0, 0,
		851, 107, 1, 0, 0, 0, 852, 853, 5, 53, 0, 0, 853, 854, 5, 67, 0, 0, 854,
		858, 3, 36, 18, 0, 855, 856, 3, 74, 37, 0, 856, 857, 3, 106, 53, 0, 857,
		859, 1, 0, 0, 0, 858, 855, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 866,
		1, 0, 0, 0, 860, 861, 5, 53, 0, 0, 861, 862, 5, 67, 0, 0, 862, 863, 3,
		74, 37, 0, 863, 864, 3, 106, 53, 0, 864, 866, 1, 0, 0, 0, 865, 852, 1,
		0, 0, 0, 865, 860, 1, 0, 0, 0, 866, 109, 1, 0, 0, 0, 867, 871, 5, 54, 0,
		0, 868, 869, 3, 68, 34, 0, 869, 870, 5, 55, 0, 0, 870, 872, 1, 0, 0, 0,
		871, 868, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873,
		874, 3, 98, 49, 0, 874, 876, 3, 56, 28, 0, 875, 877, 3, 112, 56, 0, 876,
		875, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 111, 1, 0, 0, 0, 878, 881,
		5, 56, 0, 0, 879, 882, 3, 110, 55, 0, 880, 882, 3, 56, 28, 0, 881, 879,
		1, 0, 0, 0, 881, 880, 1, 0, 0, 0, 882, 113, 1, 0, 0, 0, 883, 885, 5, 63,
		0, 0, 884, 883, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 887, 1, 0, 0, 0,
		886, 888, 5, 64, 0, 0, 887, 886, 1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888,
		889, 1, 0, 0, 0, 889, 890, 5, 67, 0, 0, 890, 891, 7, 5, 0, 0, 891, 115,
		1, 0, 0, 0, 892, 897, 5, 59, 0, 0, 893, 898, 3, 118, 59, 0, 894, 898, 3,
		120, 60, 0, 895, 898, 3, 122, 61, 0, 896, 898, 3, 124, 62, 0, 897, 893,
		1, 0, 0, 0, 897, 894, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897, 896, 1, 0,
		0, 0, 898, 899, 1, 0, 0, 0, 899, 900, 3, 56, 28, 0, 900, 117, 1, 0, 0,
		0, 901, 903, 3, 126, 63, 0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0,
		903, 904, 1, 0, 0, 0, 904, 906, 5, 55, 0, 0, 905, 907, 3, 82, 41, 0, 906,
		905, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 910,
		5, 55, 0, 0, 909, 911, 3, 126, 63, 0, 910, 909, 1, 0, 0, 0, 910, 911, 1,
		0, 0, 0, 911, 119, 1, 0, 0, 0, 912, 913, 3, 128, 64, 0, 913, 914, 5, 26,
		0, 0, 914, 916, 1, 0, 0, 0, 915, 912, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0,
		916, 917, 1, 0, 0, 0, 917, 918, 5, 60, 0, 0, 918, 919, 3, 82, 41, 0, 919,
		121, 1, 0, 0, 0, 920, 921, 3, 82, 41, 0, 921, 123, 1, 0, 0, 0, 922, 923,
		1, 0, 0, 0, 923, 125, 1, 0, 0, 0, 924, 928, 3, 68, 34, 0, 925, 928, 3,
		82, 41, 0, 926, 928, 3, 114, 57, 0, 927, 924, 1, 0, 0, 0, 927, 925, 1,
		0, 0, 0, 927, 926, 1, 0, 0, 0, 928, 127, 1, 0, 0, 0, 929, 934, 3, 82, 41,
		0, 930, 931, 5, 13, 0, 0, 931, 933, 3, 82, 41, 0, 932, 930, 1, 0, 0, 0,
		933, 936, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935,
		129, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 937, 938, 3, 36, 18, 0, 938, 950,
		5, 2, 0, 0, 939, 944, 3, 92, 46, 0, 940, 941, 5, 13, 0, 0, 941, 943, 3,
		92, 46, 0, 942, 940, 1, 0, 0, 0, 943, 946, 1, 0, 0, 0, 944, 942, 1, 0,
		0, 0, 944, 945, 1, 0, 0, 0, 945, 948, 1, 0, 0, 0, 946, 944, 1, 0, 0, 0,
		947, 949, 5, 13, 0, 0, 948, 947, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949,
		951, 1, 0, 0, 0, 950, 939, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 952,
		1, 0, 0, 0, 952, 953, 5, 3, 0, 0, 953, 131, 1, 0, 0, 0, 954, 955, 5, 61,
		0, 0, 955, 956, 3, 82, 41, 0, 956, 957, 5, 7, 0, 0, 957, 960, 5, 67, 0,
		0, 958, 959, 5, 13, 0, 0, 959, 961, 5, 67, 0, 0, 960, 958, 1, 0, 0, 0,
		960, 961, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 963, 3, 56, 28, 0, 963,
		133, 1, 0, 0, 0, 964, 965, 5, 67, 0, 0, 965, 966, 5, 4, 0, 0, 966, 967,
		3, 82, 41, 0, 967, 968, 5, 5, 0, 0, 968, 135, 1, 0, 0, 0, 135, 139, 150,
		162, 170, 174, 180, 184, 188, 202, 209, 215, 221, 227, 231, 237, 249, 252,
		262, 265, 276, 286, 294, 301, 308, 311, 314, 318, 321, 326, 329, 333, 338,
		341, 350, 353, 358, 364, 370, 374, 380, 385, 395, 402, 412, 419, 426, 431,
		437, 455, 463, 467, 477, 485, 490, 493, 500, 510, 513, 516, 522, 529, 533,
		536, 545, 556, 561, 564, 573, 578, 583, 587, 591, 593, 600, 607, 615, 618,
		624, 629, 636, 641, 651, 658, 661, 667, 674, 677, 681, 683, 692, 695, 699,
		720, 723, 732, 736, 738, 752, 756, 758, 767, 771, 773, 783, 787, 789, 796,
		805, 809, 811, 818, 827, 833, 837, 841, 845, 850, 858, 865, 871, 876, 881,
		884, 887, 897, 902, 906, 910, 915, 927, 934, 944, 948, 950, 960,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// GoSugarParserInit initializes any static state used to implement GoSugarParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGoSugarParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GoSugarParserInit() {
	staticData := &GoSugarParserStaticData
	staticData.once.Do(gosugarParserInit)
}

// NewGoSugarParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGoSugarParser(input antlr.TokenStream) *GoSugarParser {
	GoSugarParserInit()
	this := new(GoSugarParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &GoSugarParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "GoSugar.g4"

	return this
}

// GoSugarParser tokens.
const (
	GoSugarParserEOF              = antlr.TokenEOF
	GoSugarParserT__0             = 1
	GoSugarParserT__1             = 2
	GoSugarParserT__2             = 3
	GoSugarParserT__3             = 4
	GoSugarParserT__4             = 5
	GoSugarParserT__5             = 6
	GoSugarParserT__6             = 7
	GoSugarParserT__7             = 8
	GoSugarParserT__8             = 9
	GoSugarParserT__9             = 10
	GoSugarParserT__10            = 11
	GoSugarParserT__11            = 12
	GoSugarParserT__12            = 13
	GoSugarParserT__13            = 14
	GoSugarParserT__14            = 15
	GoSugarParserT__15            = 16
	GoSugarParserT__16            = 17
	GoSugarParserT__17            = 18
	GoSugarParserT__18            = 19
	GoSugarParserT__19            = 20
	GoSugarParserT__20            = 21
	GoSugarParserT__21            = 22
	GoSugarParserT__22            = 23
	GoSugarParserT__23            = 24
	GoSugarParserT__24            = 25
	GoSugarParserT__25            = 26
	GoSugarParserT__26            = 27
	GoSugarParserT__27            = 28
	GoSugarParserT__28            = 29
	GoSugarParserT__29            = 30
	GoSugarParserT__30            = 31
	GoSugarParserT__31            = 32
	GoSugarParserT__32            = 33
	GoSugarParserT__33            = 34
	GoSugarParserT__34            = 35
	GoSugarParserT__35            = 36
	GoSugarParserT__36            = 37
	GoSugarParserT__37            = 38
	GoSugarParserT__38            = 39
	GoSugarParserT__39            = 40
	GoSugarParserT__40            = 41
	GoSugarParserT__41            = 42
	GoSugarParserT__42            = 43
	GoSugarParserT__43            = 44
	GoSugarParserT__44            = 45
	GoSugarParserT__45            = 46
	GoSugarParserT__46            = 47
	GoSugarParserT__47            = 48
	GoSugarParserT__48            = 49
	GoSugarParserT__49            = 50
	GoSugarParserT__50            = 51
	GoSugarParserT__51            = 52
	GoSugarParserT__52            = 53
	GoSugarParserT__53            = 54
	GoSugarParserT__54            = 55
	GoSugarParserT__55            = 56
	GoSugarParserT__56            = 57
	GoSugarParserT__57            = 58
	GoSugarParserT__58            = 59
	GoSugarParserT__59            = 60
	GoSugarParserT__60            = 61
	GoSugarParserELLIPSIS         = 62
	GoSugarParserSTAR             = 63
	GoSugarParserAMPERSAND        = 64
	GoSugarParserCREATE           = 65
	GoSugarParserSTATIC           = 66
	GoSugarParserIDENTIFIER       = 67
	GoSugarParserNUMBER           = 68
	GoSugarParserPOSITIVE_INTEGER = 69
	GoSugarParserDOT              = 70
	GoSugarParserSTRING           = 71
	GoSugarParserNIL              = 72
	GoSugarParserWS               = 73
	GoSugarParserBlockComment     = 74
	GoSugarParserLineComment      = 75
	GoSugarParserNEWLINE          = 76
)

// GoSugarParser rules.
const (
	GoSugarParserRULE_program                       = 0
	GoSugarParserRULE_programDeclaration            = 1
	GoSugarParserRULE_globalVarStatement            = 2
	GoSugarParserRULE_interfaceDeclaration          = 3
	GoSugarParserRULE_interfaceBody                 = 4
	GoSugarParserRULE_interfaceMethod               = 5
	GoSugarParserRULE_classDeclaration              = 6
	GoSugarParserRULE_packageDeclaration            = 7
	GoSugarParserRULE_importsDeclaration            = 8
	GoSugarParserRULE_createObjectDeclaration       = 9
	GoSugarParserRULE_sliceDeclaration              = 10
	GoSugarParserRULE_sliceOrArrayLiteral           = 11
	GoSugarParserRULE_listAccess                    = 12
	GoSugarParserRULE_aliasType                     = 13
	GoSugarParserRULE_compositionList               = 14
	GoSugarParserRULE_mustInterfaceList             = 15
	GoSugarParserRULE_classBody                     = 16
	GoSugarParserRULE_classMember                   = 17
	GoSugarParserRULE_varType                       = 18
	GoSugarParserRULE_fieldDeclaration              = 19
	GoSugarParserRULE_methodDeclaration             = 20
	GoSugarParserRULE_anonimousFunctionDeclaration  = 21
	GoSugarParserRULE_returnType                    = 22
	GoSugarParserRULE_returnTypeList                = 23
	GoSugarParserRULE_returnTypeSingle              = 24
	GoSugarParserRULE_parameterList                 = 25
	GoSugarParserRULE_methodBody                    = 26
	GoSugarParserRULE_parameter                     = 27
	GoSugarParserRULE_block                         = 28
	GoSugarParserRULE_statement                     = 29
	GoSugarParserRULE_switchStatement               = 30
	GoSugarParserRULE_caseBlock                     = 31
	GoSugarParserRULE_defaultBlock                  = 32
	GoSugarParserRULE_negationExpression            = 33
	GoSugarParserRULE_assignment                    = 34
	GoSugarParserRULE_assignmentLeftHandSide        = 35
	GoSugarParserRULE_leftHandSide                  = 36
	GoSugarParserRULE_assignmentOperator            = 37
	GoSugarParserRULE_comparisonOperator            = 38
	GoSugarParserRULE_methodCall                    = 39
	GoSugarParserRULE_argumentList                  = 40
	GoSugarParserRULE_expression                    = 41
	GoSugarParserRULE_concatenatedString            = 42
	GoSugarParserRULE_interfaceTypeVerification     = 43
	GoSugarParserRULE_primaryExpression             = 44
	GoSugarParserRULE_directCreateInstance          = 45
	GoSugarParserRULE_mapKeyValue                   = 46
	GoSugarParserRULE_listLiteral                   = 47
	GoSugarParserRULE_operatorExpression            = 48
	GoSugarParserRULE_comparison                    = 49
	GoSugarParserRULE_returnOperation               = 50
	GoSugarParserRULE_continueOperation             = 51
	GoSugarParserRULE_breakOperation                = 52
	GoSugarParserRULE_varValue                      = 53
	GoSugarParserRULE_varStatement                  = 54
	GoSugarParserRULE_ifStatement                   = 55
	GoSugarParserRULE_elseStatement                 = 56
	GoSugarParserRULE_incrementOrDecrementStatement = 57
	GoSugarParserRULE_forStatement                  = 58
	GoSugarParserRULE_classicForLoop                = 59
	GoSugarParserRULE_rangeForLoop                  = 60
	GoSugarParserRULE_conditionForLoop              = 61
	GoSugarParserRULE_infiniteForLoop               = 62
	GoSugarParserRULE_simpleStatement               = 63
	GoSugarParserRULE_expressionList                = 64
	GoSugarParserRULE_mapInitialization             = 65
	GoSugarParserRULE_foreachStatement              = 66
	GoSugarParserRULE_typeConversion                = 67
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllProgramDeclaration() []IProgramDeclarationContext
	ProgramDeclaration(i int) IProgramDeclarationContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(GoSugarParserEOF, 0)
}

func (s *ProgramContext) AllProgramDeclaration() []IProgramDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProgramDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProgramDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProgramDeclarationContext); ok {
			tst[i] = t.(IProgramDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) ProgramDeclaration(i int) IProgramDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramDeclarationContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *GoSugarParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GoSugarParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9007199254875202) != 0) || _la == GoSugarParserSTATIC {
		{
			p.SetState(136)
			p.ProgramDeclaration()
		}

		p.SetState(141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(142)
		p.Match(GoSugarParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramDeclarationContext is an interface to support dynamic dispatch.
type IProgramDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportsDeclaration() IImportsDeclarationContext
	GlobalVarStatement() IGlobalVarStatementContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	PackageDeclaration() IPackageDeclarationContext
	MethodDeclaration() IMethodDeclarationContext

	// IsProgramDeclarationContext differentiates from other interfaces.
	IsProgramDeclarationContext()
}

type ProgramDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramDeclarationContext() *ProgramDeclarationContext {
	var p = new(ProgramDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_programDeclaration
	return p
}

func InitEmptyProgramDeclarationContext(p *ProgramDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_programDeclaration
}

func (*ProgramDeclarationContext) IsProgramDeclarationContext() {}

func NewProgramDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramDeclarationContext {
	var p = new(ProgramDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_programDeclaration

	return p
}

func (s *ProgramDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramDeclarationContext) ImportsDeclaration() IImportsDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportsDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportsDeclarationContext)
}

func (s *ProgramDeclarationContext) GlobalVarStatement() IGlobalVarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalVarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalVarStatementContext)
}

func (s *ProgramDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *ProgramDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ProgramDeclarationContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *ProgramDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *ProgramDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterProgramDeclaration(s)
	}
}

func (s *ProgramDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitProgramDeclaration(s)
	}
}

func (p *GoSugarParser) ProgramDeclaration() (localctx IProgramDeclarationContext) {
	localctx = NewProgramDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GoSugarParserRULE_programDeclaration)
	p.SetState(150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoSugarParserT__10:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(144)
			p.ImportsDeclaration()
		}

	case GoSugarParserT__52:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(145)
			p.GlobalVarStatement()
		}

	case GoSugarParserT__0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(146)
			p.InterfaceDeclaration()
		}

	case GoSugarParserT__5:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(147)
			p.ClassDeclaration()
		}

	case GoSugarParserT__9:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(148)
			p.PackageDeclaration()
		}

	case GoSugarParserT__16, GoSugarParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(149)
			p.MethodDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobalVarStatementContext is an interface to support dynamic dispatch.
type IGlobalVarStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarStatement() IVarStatementContext

	// IsGlobalVarStatementContext differentiates from other interfaces.
	IsGlobalVarStatementContext()
}

type GlobalVarStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalVarStatementContext() *GlobalVarStatementContext {
	var p = new(GlobalVarStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_globalVarStatement
	return p
}

func InitEmptyGlobalVarStatementContext(p *GlobalVarStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_globalVarStatement
}

func (*GlobalVarStatementContext) IsGlobalVarStatementContext() {}

func NewGlobalVarStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalVarStatementContext {
	var p = new(GlobalVarStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_globalVarStatement

	return p
}

func (s *GlobalVarStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalVarStatementContext) VarStatement() IVarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarStatementContext)
}

func (s *GlobalVarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalVarStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalVarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterGlobalVarStatement(s)
	}
}

func (s *GlobalVarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitGlobalVarStatement(s)
	}
}

func (p *GoSugarParser) GlobalVarStatement() (localctx IGlobalVarStatementContext) {
	localctx = NewGlobalVarStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GoSugarParserRULE_globalVarStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(152)
		p.VarStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	InterfaceBody() IInterfaceBodyContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *InterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (p *GoSugarParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GoSugarParserRULE_interfaceDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)
		p.Match(GoSugarParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(155)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(156)
		p.InterfaceBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceBody
	return p
}

func InitEmptyInterfaceBodyContext(p *InterfaceBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceBody
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}

func (p *GoSugarParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GoSugarParserRULE_interfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(158)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(159)
			p.InterfaceMethod()
		}

		p.SetState(164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(165)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *InterfaceMethodContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InterfaceMethodContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (p *GoSugarParser) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GoSugarParserRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(167)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(168)
		p.Match(GoSugarParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(169)
			p.ParameterList()
		}

	}
	{
		p.SetState(172)
		p.Match(GoSugarParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(174)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(173)
			p.ReturnType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ClassBody() IClassBodyContext
	AliasType() IAliasTypeContext
	CompositionList() ICompositionListContext
	MustInterfaceList() IMustInterfaceListContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) AliasType() IAliasTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasTypeContext)
}

func (s *ClassDeclarationContext) CompositionList() ICompositionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositionListContext)
}

func (s *ClassDeclarationContext) MustInterfaceList() IMustInterfaceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMustInterfaceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMustInterfaceListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *GoSugarParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GoSugarParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(176)
		p.Match(GoSugarParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(177)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__6 {
		{
			p.SetState(178)
			p.Match(GoSugarParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(179)
			p.AliasType()
		}

	}
	p.SetState(184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__7 {
		{
			p.SetState(182)
			p.Match(GoSugarParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(183)
			p.CompositionList()
		}

	}
	p.SetState(188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__8 {
		{
			p.SetState(186)
			p.Match(GoSugarParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(187)
			p.MustInterfaceList()
		}

	}
	{
		p.SetState(190)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_packageDeclaration
	return p
}

func InitEmptyPackageDeclarationContext(p *PackageDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_packageDeclaration
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (p *GoSugarParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GoSugarParserRULE_packageDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(192)
		p.Match(GoSugarParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(193)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportsDeclarationContext is an interface to support dynamic dispatch.
type IImportsDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	AllWS() []antlr.TerminalNode
	WS(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsImportsDeclarationContext differentiates from other interfaces.
	IsImportsDeclarationContext()
}

type ImportsDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportsDeclarationContext() *ImportsDeclarationContext {
	var p = new(ImportsDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_importsDeclaration
	return p
}

func InitEmptyImportsDeclarationContext(p *ImportsDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_importsDeclaration
}

func (*ImportsDeclarationContext) IsImportsDeclarationContext() {}

func NewImportsDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportsDeclarationContext {
	var p = new(ImportsDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_importsDeclaration

	return p
}

func (s *ImportsDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportsDeclarationContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserSTRING)
}

func (s *ImportsDeclarationContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTRING, i)
}

func (s *ImportsDeclarationContext) AllWS() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserWS)
}

func (s *ImportsDeclarationContext) WS(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserWS, i)
}

func (s *ImportsDeclarationContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserNEWLINE)
}

func (s *ImportsDeclarationContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserNEWLINE, i)
}

func (s *ImportsDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportsDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportsDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterImportsDeclaration(s)
	}
}

func (s *ImportsDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitImportsDeclaration(s)
	}
}

func (p *GoSugarParser) ImportsDeclaration() (localctx IImportsDeclarationContext) {
	localctx = NewImportsDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GoSugarParserRULE_importsDeclaration)
	var _la int

	var _alt int

	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(195)
			p.Match(GoSugarParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)
			p.Match(GoSugarParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(197)
			p.Match(GoSugarParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(198)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GoSugarParserWS {
			{
				p.SetState(199)
				p.Match(GoSugarParserWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(204)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(205)
			p.Match(GoSugarParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&37) != 0 {
			p.SetState(209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(206)
						p.Match(GoSugarParserWS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(211)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(215)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == GoSugarParserNEWLINE {
				{
					p.SetState(212)
					p.Match(GoSugarParserNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(217)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(221)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == GoSugarParserWS {
				{
					p.SetState(218)
					p.Match(GoSugarParserWS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(223)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(224)
				p.Match(GoSugarParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(229)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(230)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateObjectDeclarationContext is an interface to support dynamic dispatch.
type ICreateObjectDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	ArgumentList() IArgumentListContext

	// IsCreateObjectDeclarationContext differentiates from other interfaces.
	IsCreateObjectDeclarationContext()
}

type CreateObjectDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateObjectDeclarationContext() *CreateObjectDeclarationContext {
	var p = new(CreateObjectDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_createObjectDeclaration
	return p
}

func InitEmptyCreateObjectDeclarationContext(p *CreateObjectDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_createObjectDeclaration
}

func (*CreateObjectDeclarationContext) IsCreateObjectDeclarationContext() {}

func NewCreateObjectDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateObjectDeclarationContext {
	var p = new(CreateObjectDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_createObjectDeclaration

	return p
}

func (s *CreateObjectDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateObjectDeclarationContext) CREATE() antlr.TerminalNode {
	return s.GetToken(GoSugarParserCREATE, 0)
}

func (s *CreateObjectDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *CreateObjectDeclarationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CreateObjectDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateObjectDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateObjectDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterCreateObjectDeclaration(s)
	}
}

func (s *CreateObjectDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitCreateObjectDeclaration(s)
	}
}

func (p *GoSugarParser) CreateObjectDeclaration() (localctx ICreateObjectDeclarationContext) {
	localctx = NewCreateObjectDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GoSugarParserRULE_createObjectDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Match(GoSugarParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(234)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(235)
		p.Match(GoSugarParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
		{
			p.SetState(236)
			p.ArgumentList()
		}

	}
	{
		p.SetState(239)
		p.Match(GoSugarParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISliceDeclarationContext is an interface to support dynamic dispatch.
type ISliceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsSliceDeclarationContext differentiates from other interfaces.
	IsSliceDeclarationContext()
}

type SliceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceDeclarationContext() *SliceDeclarationContext {
	var p = new(SliceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_sliceDeclaration
	return p
}

func InitEmptySliceDeclarationContext(p *SliceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_sliceDeclaration
}

func (*SliceDeclarationContext) IsSliceDeclarationContext() {}

func NewSliceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceDeclarationContext {
	var p = new(SliceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_sliceDeclaration

	return p
}

func (s *SliceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *SliceDeclarationContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SliceDeclarationContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SliceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterSliceDeclaration(s)
	}
}

func (s *SliceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitSliceDeclaration(s)
	}
}

func (p *GoSugarParser) SliceDeclaration() (localctx ISliceDeclarationContext) {
	localctx = NewSliceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GoSugarParserRULE_sliceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.Match(GoSugarParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(242)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(243)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
		{
			p.SetState(244)
			p.PrimaryExpression()
		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GoSugarParserT__12 {
			{
				p.SetState(245)
				p.Match(GoSugarParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(246)
				p.PrimaryExpression()
			}

			p.SetState(251)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(254)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISliceOrArrayLiteralContext is an interface to support dynamic dispatch.
type ISliceOrArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsSliceOrArrayLiteralContext differentiates from other interfaces.
	IsSliceOrArrayLiteralContext()
}

type SliceOrArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceOrArrayLiteralContext() *SliceOrArrayLiteralContext {
	var p = new(SliceOrArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_sliceOrArrayLiteral
	return p
}

func InitEmptySliceOrArrayLiteralContext(p *SliceOrArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_sliceOrArrayLiteral
}

func (*SliceOrArrayLiteralContext) IsSliceOrArrayLiteralContext() {}

func NewSliceOrArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceOrArrayLiteralContext {
	var p = new(SliceOrArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_sliceOrArrayLiteral

	return p
}

func (s *SliceOrArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceOrArrayLiteralContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SliceOrArrayLiteralContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SliceOrArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceOrArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceOrArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterSliceOrArrayLiteral(s)
	}
}

func (s *SliceOrArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitSliceOrArrayLiteral(s)
	}
}

func (p *GoSugarParser) SliceOrArrayLiteral() (localctx ISliceOrArrayLiteralContext) {
	localctx = NewSliceOrArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GoSugarParserRULE_sliceOrArrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.Match(GoSugarParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
		{
			p.SetState(257)
			p.PrimaryExpression()
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GoSugarParserT__12 {
			{
				p.SetState(258)
				p.Match(GoSugarParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(259)
				p.PrimaryExpression()
			}

			p.SetState(264)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(267)
		p.Match(GoSugarParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListAccessContext is an interface to support dynamic dispatch.
type IListAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftHandSide() ILeftHandSideContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsListAccessContext differentiates from other interfaces.
	IsListAccessContext()
}

type ListAccessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListAccessContext() *ListAccessContext {
	var p = new(ListAccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_listAccess
	return p
}

func InitEmptyListAccessContext(p *ListAccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_listAccess
}

func (*ListAccessContext) IsListAccessContext() {}

func NewListAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListAccessContext {
	var p = new(ListAccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_listAccess

	return p
}

func (s *ListAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *ListAccessContext) LeftHandSide() ILeftHandSideContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *ListAccessContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListAccessContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterListAccess(s)
	}
}

func (s *ListAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitListAccess(s)
	}
}

func (p *GoSugarParser) ListAccess() (localctx IListAccessContext) {
	localctx = NewListAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GoSugarParserRULE_listAccess)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.LeftHandSide()
	}
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(270)
				p.Match(GoSugarParserT__13)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(271)
				p.Expression()
			}
			{
				p.SetState(272)
				p.Match(GoSugarParserT__14)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasTypeContext is an interface to support dynamic dispatch.
type IAliasTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarType() IVarTypeContext

	// IsAliasTypeContext differentiates from other interfaces.
	IsAliasTypeContext()
}

type AliasTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasTypeContext() *AliasTypeContext {
	var p = new(AliasTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_aliasType
	return p
}

func InitEmptyAliasTypeContext(p *AliasTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_aliasType
}

func (*AliasTypeContext) IsAliasTypeContext() {}

func NewAliasTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasTypeContext {
	var p = new(AliasTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_aliasType

	return p
}

func (s *AliasTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasTypeContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *AliasTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterAliasType(s)
	}
}

func (s *AliasTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitAliasType(s)
	}
}

func (p *GoSugarParser) AliasType() (localctx IAliasTypeContext) {
	localctx = NewAliasTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GoSugarParserRULE_aliasType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.VarType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositionListContext is an interface to support dynamic dispatch.
type ICompositionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLeftHandSide() []ILeftHandSideContext
	LeftHandSide(i int) ILeftHandSideContext

	// IsCompositionListContext differentiates from other interfaces.
	IsCompositionListContext()
}

type CompositionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositionListContext() *CompositionListContext {
	var p = new(CompositionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_compositionList
	return p
}

func InitEmptyCompositionListContext(p *CompositionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_compositionList
}

func (*CompositionListContext) IsCompositionListContext() {}

func NewCompositionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositionListContext {
	var p = new(CompositionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_compositionList

	return p
}

func (s *CompositionListContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositionListContext) AllLeftHandSide() []ILeftHandSideContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			len++
		}
	}

	tst := make([]ILeftHandSideContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILeftHandSideContext); ok {
			tst[i] = t.(ILeftHandSideContext)
			i++
		}
	}

	return tst
}

func (s *CompositionListContext) LeftHandSide(i int) ILeftHandSideContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *CompositionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterCompositionList(s)
	}
}

func (s *CompositionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitCompositionList(s)
	}
}

func (p *GoSugarParser) CompositionList() (localctx ICompositionListContext) {
	localctx = NewCompositionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GoSugarParserRULE_compositionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(281)
		p.LeftHandSide()
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__12 {
		{
			p.SetState(282)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(283)
			p.LeftHandSide()
		}

		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMustInterfaceListContext is an interface to support dynamic dispatch.
type IMustInterfaceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode

	// IsMustInterfaceListContext differentiates from other interfaces.
	IsMustInterfaceListContext()
}

type MustInterfaceListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMustInterfaceListContext() *MustInterfaceListContext {
	var p = new(MustInterfaceListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_mustInterfaceList
	return p
}

func InitEmptyMustInterfaceListContext(p *MustInterfaceListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_mustInterfaceList
}

func (*MustInterfaceListContext) IsMustInterfaceListContext() {}

func NewMustInterfaceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MustInterfaceListContext {
	var p = new(MustInterfaceListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_mustInterfaceList

	return p
}

func (s *MustInterfaceListContext) GetParser() antlr.Parser { return s.parser }

func (s *MustInterfaceListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserIDENTIFIER)
}

func (s *MustInterfaceListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, i)
}

func (s *MustInterfaceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MustInterfaceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MustInterfaceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterMustInterfaceList(s)
	}
}

func (s *MustInterfaceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitMustInterfaceList(s)
	}
}

func (p *GoSugarParser) MustInterfaceList() (localctx IMustInterfaceListContext) {
	localctx = NewMustInterfaceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GoSugarParserRULE_mustInterfaceList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__12 {
		{
			p.SetState(290)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(291)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassMember() []IClassMemberContext
	ClassMember(i int) IClassMemberContext

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) AllClassMember() []IClassMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMemberContext); ok {
			len++
		}
	}

	tst := make([]IClassMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMemberContext); ok {
			tst[i] = t.(IClassMemberContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassMember(i int) IClassMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *GoSugarParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GoSugarParserRULE_classBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-17)) & ^0x3f) == 0 && ((int64(1)<<(_la-17))&1688849860263937) != 0 {
		{
			p.SetState(298)
			p.ClassMember()
		}

		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(304)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMemberContext is an interface to support dynamic dispatch.
type IClassMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldDeclaration() IFieldDeclarationContext
	MethodDeclaration() IMethodDeclarationContext

	// IsClassMemberContext differentiates from other interfaces.
	IsClassMemberContext()
}

type ClassMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberContext() *ClassMemberContext {
	var p = new(ClassMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classMember
	return p
}

func InitEmptyClassMemberContext(p *ClassMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classMember
}

func (*ClassMemberContext) IsClassMemberContext() {}

func NewClassMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberContext {
	var p = new(ClassMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_classMember

	return p
}

func (s *ClassMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *ClassMemberContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *ClassMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterClassMember(s)
	}
}

func (s *ClassMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitClassMember(s)
	}
}

func (p *GoSugarParser) ClassMember() (localctx IClassMemberContext) {
	localctx = NewClassMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GoSugarParserRULE_classMember)
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoSugarParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(306)
			p.FieldDeclaration()
		}

	case GoSugarParserT__16, GoSugarParserSTATIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(307)
			p.MethodDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarTypeContext is an interface to support dynamic dispatch.
type IVarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	AllVarType() []IVarTypeContext
	VarType(i int) IVarTypeContext
	NUMBER() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsVarTypeContext differentiates from other interfaces.
	IsVarTypeContext()
}

type VarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarTypeContext() *VarTypeContext {
	var p = new(VarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_varType
	return p
}

func InitEmptyVarTypeContext(p *VarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_varType
}

func (*VarTypeContext) IsVarTypeContext() {}

func NewVarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarTypeContext {
	var p = new(VarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_varType

	return p
}

func (s *VarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarTypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *VarTypeContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, 0)
}

func (s *VarTypeContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoSugarParserAMPERSAND, 0)
}

func (s *VarTypeContext) AllVarType() []IVarTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVarTypeContext); ok {
			len++
		}
	}

	tst := make([]IVarTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVarTypeContext); ok {
			tst[i] = t.(IVarTypeContext)
			i++
		}
	}

	return tst
}

func (s *VarTypeContext) VarType(i int) IVarTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *VarTypeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserNUMBER, 0)
}

func (s *VarTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoSugarParserDOT, 0)
}

func (s *VarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterVarType(s)
	}
}

func (s *VarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitVarType(s)
	}
}

func (p *GoSugarParser) VarType() (localctx IVarTypeContext) {
	localctx = NewVarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GoSugarParserRULE_varType)
	var _la int

	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(310)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(313)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(316)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(317)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(320)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(323)
			p.Match(GoSugarParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(324)
			p.VarType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(325)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(328)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(331)
			p.Match(GoSugarParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserNUMBER {
			{
				p.SetState(332)
				p.Match(GoSugarParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(335)
			p.Match(GoSugarParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)
			p.VarType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(337)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(340)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(343)
			p.Match(GoSugarParserT__15)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(344)
			p.Match(GoSugarParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)
			p.VarType()
		}
		{
			p.SetState(346)
			p.Match(GoSugarParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(347)
			p.VarType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(349)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(352)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(355)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(356)
			p.Match(GoSugarParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)
			p.VarType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	VarType() IVarTypeContext

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_fieldDeclaration
	return p
}

func InitEmptyFieldDeclarationContext(p *FieldDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_fieldDeclaration
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *FieldDeclarationContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *GoSugarParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GoSugarParserRULE_fieldDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(361)
		p.VarType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	MethodBody() IMethodBodyContext
	STATIC() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_methodDeclaration
	return p
}

func InitEmptyMethodDeclarationContext(p *MethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_methodDeclaration
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTATIC, 0)
}

func (s *MethodDeclarationContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MethodDeclarationContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *GoSugarParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, GoSugarParserRULE_methodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserSTATIC {
		{
			p.SetState(363)
			p.Match(GoSugarParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(366)
		p.Match(GoSugarParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(367)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.Match(GoSugarParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(369)
			p.ParameterList()
		}

	}
	{
		p.SetState(372)
		p.Match(GoSugarParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-4)) & ^0x3f) == 0 && ((int64(1)<<(_la-4))&-7493989779944499967) != 0 {
		{
			p.SetState(373)
			p.ReturnType()
		}

	}
	{
		p.SetState(376)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonimousFunctionDeclarationContext is an interface to support dynamic dispatch.
type IAnonimousFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodBody() IMethodBodyContext
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsAnonimousFunctionDeclarationContext differentiates from other interfaces.
	IsAnonimousFunctionDeclarationContext()
}

type AnonimousFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonimousFunctionDeclarationContext() *AnonimousFunctionDeclarationContext {
	var p = new(AnonimousFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_anonimousFunctionDeclaration
	return p
}

func InitEmptyAnonimousFunctionDeclarationContext(p *AnonimousFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_anonimousFunctionDeclaration
}

func (*AnonimousFunctionDeclarationContext) IsAnonimousFunctionDeclarationContext() {}

func NewAnonimousFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonimousFunctionDeclarationContext {
	var p = new(AnonimousFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_anonimousFunctionDeclaration

	return p
}

func (s *AnonimousFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonimousFunctionDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *AnonimousFunctionDeclarationContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *AnonimousFunctionDeclarationContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *AnonimousFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonimousFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonimousFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterAnonimousFunctionDeclaration(s)
	}
}

func (s *AnonimousFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitAnonimousFunctionDeclaration(s)
	}
}

func (p *GoSugarParser) AnonimousFunctionDeclaration() (localctx IAnonimousFunctionDeclarationContext) {
	localctx = NewAnonimousFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GoSugarParserRULE_anonimousFunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.Match(GoSugarParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(379)
			p.ParameterList()
		}

	}
	{
		p.SetState(382)
		p.Match(GoSugarParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__17 {
		{
			p.SetState(383)
			p.Match(GoSugarParserT__17)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.ReturnType()
		}

	}
	{
		p.SetState(387)
		p.Match(GoSugarParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReturnTypeList() IReturnTypeListContext
	VarType() IVarTypeContext

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnType
	return p
}

func InitEmptyReturnTypeContext(p *ReturnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnType
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_returnType

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) ReturnTypeList() IReturnTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeListContext)
}

func (s *ReturnTypeContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (p *GoSugarParser) ReturnType() (localctx IReturnTypeContext) {
	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GoSugarParserRULE_returnType)
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoSugarParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(390)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(391)
			p.ReturnTypeList()
		}
		{
			p.SetState(392)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GoSugarParserT__11, GoSugarParserT__13, GoSugarParserT__15, GoSugarParserSTAR, GoSugarParserAMPERSAND, GoSugarParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(394)
			p.VarType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnTypeListContext is an interface to support dynamic dispatch.
type IReturnTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReturnTypeSingle() []IReturnTypeSingleContext
	ReturnTypeSingle(i int) IReturnTypeSingleContext

	// IsReturnTypeListContext differentiates from other interfaces.
	IsReturnTypeListContext()
}

type ReturnTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeListContext() *ReturnTypeListContext {
	var p = new(ReturnTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnTypeList
	return p
}

func InitEmptyReturnTypeListContext(p *ReturnTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnTypeList
}

func (*ReturnTypeListContext) IsReturnTypeListContext() {}

func NewReturnTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeListContext {
	var p = new(ReturnTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_returnTypeList

	return p
}

func (s *ReturnTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeListContext) AllReturnTypeSingle() []IReturnTypeSingleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReturnTypeSingleContext); ok {
			len++
		}
	}

	tst := make([]IReturnTypeSingleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReturnTypeSingleContext); ok {
			tst[i] = t.(IReturnTypeSingleContext)
			i++
		}
	}

	return tst
}

func (s *ReturnTypeListContext) ReturnTypeSingle(i int) IReturnTypeSingleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeSingleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeSingleContext)
}

func (s *ReturnTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterReturnTypeList(s)
	}
}

func (s *ReturnTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitReturnTypeList(s)
	}
}

func (p *GoSugarParser) ReturnTypeList() (localctx IReturnTypeListContext) {
	localctx = NewReturnTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, GoSugarParserRULE_returnTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.ReturnTypeSingle()
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__12 {
		{
			p.SetState(398)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(399)
			p.ReturnTypeSingle()
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnTypeSingleContext is an interface to support dynamic dispatch.
type IReturnTypeSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarType() IVarTypeContext

	// IsReturnTypeSingleContext differentiates from other interfaces.
	IsReturnTypeSingleContext()
}

type ReturnTypeSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeSingleContext() *ReturnTypeSingleContext {
	var p = new(ReturnTypeSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnTypeSingle
	return p
}

func InitEmptyReturnTypeSingleContext(p *ReturnTypeSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnTypeSingle
}

func (*ReturnTypeSingleContext) IsReturnTypeSingleContext() {}

func NewReturnTypeSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeSingleContext {
	var p = new(ReturnTypeSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_returnTypeSingle

	return p
}

func (s *ReturnTypeSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeSingleContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ReturnTypeSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterReturnTypeSingle(s)
	}
}

func (s *ReturnTypeSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitReturnTypeSingle(s)
	}
}

func (p *GoSugarParser) ReturnTypeSingle() (localctx IReturnTypeSingleContext) {
	localctx = NewReturnTypeSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, GoSugarParserRULE_returnTypeSingle)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.VarType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *GoSugarParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, GoSugarParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Parameter()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__12 {
		{
			p.SetState(408)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.Parameter()
		}

		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_methodBody
	return p
}

func InitEmptyMethodBodyContext(p *MethodBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_methodBody
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *MethodBodyContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *GoSugarParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GoSugarParserRULE_methodBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6234107784186474492) != 0) || _la == GoSugarParserAMPERSAND || _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(416)
			p.Statement()
		}

		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(422)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	VarType() IVarTypeContext
	ELLIPSIS() antlr.TerminalNode

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *ParameterContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GoSugarParserELLIPSIS, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *GoSugarParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, GoSugarParserRULE_parameter)
	var _la int

	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(424)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-12)) & ^0x3f) == 0 && ((int64(1)<<(_la-12))&42784196460019733) != 0 {
			{
				p.SetState(425)
				p.VarType()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(428)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(429)
			p.Match(GoSugarParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(430)
			p.VarType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *GoSugarParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GoSugarParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6234107784186474492) != 0) || _la == GoSugarParserAMPERSAND || _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(434)
			p.Statement()
		}

		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(440)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment() IAssignmentContext
	MethodCall() IMethodCallContext
	ReturnOperation() IReturnOperationContext
	ContinueOperation() IContinueOperationContext
	BreakOperation() IBreakOperationContext
	VarStatement() IVarStatementContext
	ListLiteral() IListLiteralContext
	IfStatement() IIfStatementContext
	ElseStatement() IElseStatementContext
	ForStatement() IForStatementContext
	ForeachStatement() IForeachStatementContext
	IncrementOrDecrementStatement() IIncrementOrDecrementStatementContext
	SwitchStatement() ISwitchStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *StatementContext) ReturnOperation() IReturnOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnOperationContext)
}

func (s *StatementContext) ContinueOperation() IContinueOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueOperationContext)
}

func (s *StatementContext) BreakOperation() IBreakOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakOperationContext)
}

func (s *StatementContext) VarStatement() IVarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarStatementContext)
}

func (s *StatementContext) ListLiteral() IListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) ElseStatement() IElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) ForeachStatement() IForeachStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachStatementContext)
}

func (s *StatementContext) IncrementOrDecrementStatement() IIncrementOrDecrementStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncrementOrDecrementStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncrementOrDecrementStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *GoSugarParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GoSugarParserRULE_statement)
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(442)
			p.Assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(443)
			p.MethodCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(444)
			p.ReturnOperation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(445)
			p.ContinueOperation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(446)
			p.BreakOperation()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(447)
			p.VarStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(448)
			p.ListLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(449)
			p.IfStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(450)
			p.ElseStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(451)
			p.ForStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(452)
			p.ForeachStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(453)
			p.IncrementOrDecrementStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(454)
			p.SwitchStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllCaseBlock() []ICaseBlockContext
	CaseBlock(i int) ICaseBlockContext
	DefaultBlock() IDefaultBlockContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) AllCaseBlock() []ICaseBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseBlockContext); ok {
			len++
		}
	}

	tst := make([]ICaseBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseBlockContext); ok {
			tst[i] = t.(ICaseBlockContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) CaseBlock(i int) ICaseBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) DefaultBlock() IDefaultBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *GoSugarParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GoSugarParserRULE_switchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(GoSugarParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)
		p.Expression()
	}
	{
		p.SetState(459)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__20 {
		{
			p.SetState(460)
			p.CaseBlock()
		}

		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__21 {
		{
			p.SetState(466)
			p.DefaultBlock()
		}

	}
	{
		p.SetState(469)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_caseBlock
	return p
}

func InitEmptyCaseBlockContext(p *CaseBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_caseBlock
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CaseBlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseBlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (p *GoSugarParser) CaseBlock() (localctx ICaseBlockContext) {
	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GoSugarParserRULE_caseBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(GoSugarParserT__20)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.ExpressionList()
	}
	{
		p.SetState(473)
		p.Match(GoSugarParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6234107784186474492) != 0) || _la == GoSugarParserAMPERSAND || _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(474)
			p.Statement()
		}

		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultBlockContext is an interface to support dynamic dispatch.
type IDefaultBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsDefaultBlockContext differentiates from other interfaces.
	IsDefaultBlockContext()
}

type DefaultBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultBlockContext() *DefaultBlockContext {
	var p = new(DefaultBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_defaultBlock
	return p
}

func InitEmptyDefaultBlockContext(p *DefaultBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_defaultBlock
}

func (*DefaultBlockContext) IsDefaultBlockContext() {}

func NewDefaultBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultBlockContext {
	var p = new(DefaultBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_defaultBlock

	return p
}

func (s *DefaultBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultBlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *DefaultBlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DefaultBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterDefaultBlock(s)
	}
}

func (s *DefaultBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitDefaultBlock(s)
	}
}

func (p *GoSugarParser) DefaultBlock() (localctx IDefaultBlockContext) {
	localctx = NewDefaultBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GoSugarParserRULE_defaultBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		p.Match(GoSugarParserT__21)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(481)
		p.Match(GoSugarParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6234107784186474492) != 0) || _la == GoSugarParserAMPERSAND || _la == GoSugarParserIDENTIFIER {
		{
			p.SetState(482)
			p.Statement()
		}

		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INegationExpressionContext is an interface to support dynamic dispatch.
type INegationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode

	// IsNegationExpressionContext differentiates from other interfaces.
	IsNegationExpressionContext()
}

type NegationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNegationExpressionContext() *NegationExpressionContext {
	var p = new(NegationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_negationExpression
	return p
}

func InitEmptyNegationExpressionContext(p *NegationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_negationExpression
}

func (*NegationExpressionContext) IsNegationExpressionContext() {}

func NewNegationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NegationExpressionContext {
	var p = new(NegationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_negationExpression

	return p
}

func (s *NegationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NegationExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NegationExpressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, 0)
}

func (s *NegationExpressionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoSugarParserAMPERSAND, 0)
}

func (s *NegationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NegationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterNegationExpression(s)
	}
}

func (s *NegationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitNegationExpression(s)
	}
}

func (p *GoSugarParser) NegationExpression() (localctx INegationExpressionContext) {
	localctx = NewNegationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GoSugarParserRULE_negationExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(488)
		p.Match(GoSugarParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(489)
			p.Match(GoSugarParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(492)
			p.Match(GoSugarParserAMPERSAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(495)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignmentLeftHandSide() []IAssignmentLeftHandSideContext
	AssignmentLeftHandSide(i int) IAssignmentLeftHandSideContext
	AssignmentOperator() IAssignmentOperatorContext
	Expression() IExpressionContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) AllAssignmentLeftHandSide() []IAssignmentLeftHandSideContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentLeftHandSideContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentLeftHandSideContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentLeftHandSideContext); ok {
			tst[i] = t.(IAssignmentLeftHandSideContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentContext) AssignmentLeftHandSide(i int) IAssignmentLeftHandSideContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentLeftHandSideContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentLeftHandSideContext)
}

func (s *AssignmentContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *GoSugarParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GoSugarParserRULE_assignment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.AssignmentLeftHandSide()
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__12 {
		{
			p.SetState(498)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(499)
			p.AssignmentLeftHandSide()
		}

	}
	{
		p.SetState(502)
		p.AssignmentOperator()
	}
	{
		p.SetState(503)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentLeftHandSideContext is an interface to support dynamic dispatch.
type IAssignmentLeftHandSideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLeftHandSide() []ILeftHandSideContext
	LeftHandSide(i int) ILeftHandSideContext
	ListAccess() IListAccessContext

	// IsAssignmentLeftHandSideContext differentiates from other interfaces.
	IsAssignmentLeftHandSideContext()
}

type AssignmentLeftHandSideContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentLeftHandSideContext() *AssignmentLeftHandSideContext {
	var p = new(AssignmentLeftHandSideContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_assignmentLeftHandSide
	return p
}

func InitEmptyAssignmentLeftHandSideContext(p *AssignmentLeftHandSideContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_assignmentLeftHandSide
}

func (*AssignmentLeftHandSideContext) IsAssignmentLeftHandSideContext() {}

func NewAssignmentLeftHandSideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentLeftHandSideContext {
	var p = new(AssignmentLeftHandSideContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_assignmentLeftHandSide

	return p
}

func (s *AssignmentLeftHandSideContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentLeftHandSideContext) AllLeftHandSide() []ILeftHandSideContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			len++
		}
	}

	tst := make([]ILeftHandSideContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILeftHandSideContext); ok {
			tst[i] = t.(ILeftHandSideContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentLeftHandSideContext) LeftHandSide(i int) ILeftHandSideContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *AssignmentLeftHandSideContext) ListAccess() IListAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListAccessContext)
}

func (s *AssignmentLeftHandSideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentLeftHandSideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentLeftHandSideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterAssignmentLeftHandSide(s)
	}
}

func (s *AssignmentLeftHandSideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitAssignmentLeftHandSide(s)
	}
}

func (p *GoSugarParser) AssignmentLeftHandSide() (localctx IAssignmentLeftHandSideContext) {
	localctx = NewAssignmentLeftHandSideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GoSugarParserRULE_assignmentLeftHandSide)
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.LeftHandSide()
		}

		{
			p.SetState(506)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.LeftHandSide()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)
			p.ListAccess()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeftHandSideContext is an interface to support dynamic dispatch.
type ILeftHandSideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsLeftHandSideContext differentiates from other interfaces.
	IsLeftHandSideContext()
}

type LeftHandSideContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftHandSideContext() *LeftHandSideContext {
	var p = new(LeftHandSideContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_leftHandSide
	return p
}

func InitEmptyLeftHandSideContext(p *LeftHandSideContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_leftHandSide
}

func (*LeftHandSideContext) IsLeftHandSideContext() {}

func NewLeftHandSideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftHandSideContext {
	var p = new(LeftHandSideContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_leftHandSide

	return p
}

func (s *LeftHandSideContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftHandSideContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserIDENTIFIER)
}

func (s *LeftHandSideContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, i)
}

func (s *LeftHandSideContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, 0)
}

func (s *LeftHandSideContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoSugarParserAMPERSAND, 0)
}

func (s *LeftHandSideContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserDOT)
}

func (s *LeftHandSideContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserDOT, i)
}

func (s *LeftHandSideContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LeftHandSideContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LeftHandSideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftHandSideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftHandSideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterLeftHandSide(s)
	}
}

func (s *LeftHandSideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitLeftHandSide(s)
	}
}

func (p *GoSugarParser) LeftHandSide() (localctx ILeftHandSideContext) {
	localctx = NewLeftHandSideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GoSugarParserRULE_leftHandSide)
	var _la int

	var _alt int

	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(512)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(515)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(518)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GoSugarParserT__23 {
			{
				p.SetState(519)
				p.Match(GoSugarParserT__23)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(524)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GoSugarParserDOT {
			{
				p.SetState(525)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(526)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(531)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(532)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(535)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(538)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(539)
					p.Match(GoSugarParserT__13)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(540)
					p.Expression()
				}
				{
					p.SetState(541)
					p.Match(GoSugarParserT__14)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GoSugarParserDOT {
			{
				p.SetState(548)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(549)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(556)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(550)
						p.Match(GoSugarParserT__13)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(551)
						p.Expression()
					}
					{
						p.SetState(552)
						p.Match(GoSugarParserT__14)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(558)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

			p.SetState(563)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *GoSugarParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GoSugarParserRULE_assignmentOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&137405399040) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }
func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *GoSugarParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GoSugarParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35046933135360) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallContext is an interface to support dynamic dispatch.
type IMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	DOT() antlr.TerminalNode
	MethodCall() IMethodCallContext
	LeftHandSide() ILeftHandSideContext

	// IsMethodCallContext differentiates from other interfaces.
	IsMethodCallContext()
}

type MethodCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallContext() *MethodCallContext {
	var p = new(MethodCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_methodCall
	return p
}

func InitEmptyMethodCallContext(p *MethodCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_methodCall
}

func (*MethodCallContext) IsMethodCallContext() {}

func NewMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallContext {
	var p = new(MethodCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_methodCall

	return p
}

func (s *MethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *MethodCallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *MethodCallContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoSugarParserDOT, 0)
}

func (s *MethodCallContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *MethodCallContext) LeftHandSide() ILeftHandSideContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *MethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterMethodCall(s)
	}
}

func (s *MethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitMethodCall(s)
	}
}

func (p *GoSugarParser) MethodCall() (localctx IMethodCallContext) {
	localctx = NewMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GoSugarParserRULE_methodCall)
	var _la int

	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(570)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(571)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
			{
				p.SetState(572)
				p.ArgumentList()
			}

		}
		{
			p.SetState(575)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(576)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(577)
				p.MethodCall()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(580)
			p.LeftHandSide()
		}
		{
			p.SetState(581)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
			{
				p.SetState(582)
				p.ArgumentList()
			}

		}
		{
			p.SetState(585)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(586)
				p.Match(GoSugarParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(589)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(590)
				p.MethodCall()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *GoSugarParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GoSugarParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Expression()
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__12 {
		{
			p.SetState(596)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(597)
			p.Expression()
		}

		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllOperatorExpression() []IOperatorExpressionContext
	OperatorExpression(i int) IOperatorExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ExpressionContext) AllOperatorExpression() []IOperatorExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperatorExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOperatorExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperatorExpressionContext); ok {
			tst[i] = t.(IOperatorExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) OperatorExpression(i int) IOperatorExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *GoSugarParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GoSugarParserRULE_expression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.PrimaryExpression()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(604)
				p.OperatorExpression()
			}

		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConcatenatedStringContext is an interface to support dynamic dispatch.
type IConcatenatedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsConcatenatedStringContext differentiates from other interfaces.
	IsConcatenatedStringContext()
}

type ConcatenatedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcatenatedStringContext() *ConcatenatedStringContext {
	var p = new(ConcatenatedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_concatenatedString
	return p
}

func InitEmptyConcatenatedStringContext(p *ConcatenatedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_concatenatedString
}

func (*ConcatenatedStringContext) IsConcatenatedStringContext() {}

func NewConcatenatedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenatedStringContext {
	var p = new(ConcatenatedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_concatenatedString

	return p
}

func (s *ConcatenatedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenatedStringContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserSTRING)
}

func (s *ConcatenatedStringContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTRING, i)
}

func (s *ConcatenatedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenatedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenatedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterConcatenatedString(s)
	}
}

func (s *ConcatenatedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitConcatenatedString(s)
	}
}

func (p *GoSugarParser) ConcatenatedString() (localctx IConcatenatedStringContext) {
	localctx = NewConcatenatedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GoSugarParserRULE_concatenatedString)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(GoSugarParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(611)
				p.Match(GoSugarParserT__44)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(612)
				p.Match(GoSugarParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeVerificationContext is an interface to support dynamic dispatch.
type IInterfaceTypeVerificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllMethodCall() []IMethodCallContext
	MethodCall(i int) IMethodCallContext

	// IsInterfaceTypeVerificationContext differentiates from other interfaces.
	IsInterfaceTypeVerificationContext()
}

type InterfaceTypeVerificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeVerificationContext() *InterfaceTypeVerificationContext {
	var p = new(InterfaceTypeVerificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceTypeVerification
	return p
}

func InitEmptyInterfaceTypeVerificationContext(p *InterfaceTypeVerificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_interfaceTypeVerification
}

func (*InterfaceTypeVerificationContext) IsInterfaceTypeVerificationContext() {}

func NewInterfaceTypeVerificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeVerificationContext {
	var p = new(InterfaceTypeVerificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_interfaceTypeVerification

	return p
}

func (s *InterfaceTypeVerificationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeVerificationContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserIDENTIFIER)
}

func (s *InterfaceTypeVerificationContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, i)
}

func (s *InterfaceTypeVerificationContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserDOT)
}

func (s *InterfaceTypeVerificationContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserDOT, i)
}

func (s *InterfaceTypeVerificationContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserSTAR)
}

func (s *InterfaceTypeVerificationContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, i)
}

func (s *InterfaceTypeVerificationContext) AllMethodCall() []IMethodCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodCallContext); ok {
			len++
		}
	}

	tst := make([]IMethodCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodCallContext); ok {
			tst[i] = t.(IMethodCallContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeVerificationContext) MethodCall(i int) IMethodCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *InterfaceTypeVerificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeVerificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeVerificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterInterfaceTypeVerification(s)
	}
}

func (s *InterfaceTypeVerificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitInterfaceTypeVerification(s)
	}
}

func (p *GoSugarParser) InterfaceTypeVerification() (localctx IInterfaceTypeVerificationContext) {
	localctx = NewInterfaceTypeVerificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GoSugarParserRULE_interfaceTypeVerification)
	var _la int

	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(617)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(620)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(621)
			p.Match(GoSugarParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(622)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(623)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(626)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserDOT {
			{
				p.SetState(627)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(628)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(631)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.MethodCall()
		}
		{
			p.SetState(633)
			p.Match(GoSugarParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(634)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(635)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(638)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserDOT {
			{
				p.SetState(639)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(640)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(643)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(645)
			p.Match(GoSugarParserT__45)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(647)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case GoSugarParserDOT:
			{
				p.SetState(648)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(649)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case GoSugarParserSTAR, GoSugarParserAMPERSAND, GoSugarParserIDENTIFIER:
			{
				p.SetState(650)
				p.MethodCall()
			}

		case GoSugarParserT__4:

		default:
		}
		{
			p.SetState(653)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserDOT {
			{
				p.SetState(654)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(655)
				p.Match(GoSugarParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(656)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(657)
				p.Match(GoSugarParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(660)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(663)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)
			p.Match(GoSugarParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(665)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(666)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserT__3 {
			{
				p.SetState(669)
				p.Match(GoSugarParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(670)
				p.Match(GoSugarParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case GoSugarParserDOT:
				{
					p.SetState(671)
					p.Match(GoSugarParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(672)
					p.Match(GoSugarParserIDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case GoSugarParserSTAR, GoSugarParserAMPERSAND, GoSugarParserIDENTIFIER:
				{
					p.SetState(673)
					p.MethodCall()
				}

			case GoSugarParserT__4:

			default:
			}
			{
				p.SetState(676)
				p.Match(GoSugarParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserDOT {
			{
				p.SetState(679)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(680)
				p.MethodCall()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateObjectDeclaration() ICreateObjectDeclarationContext
	SliceDeclaration() ISliceDeclarationContext
	MapInitialization() IMapInitializationContext
	SliceOrArrayLiteral() ISliceOrArrayLiteralContext
	AllMethodCall() []IMethodCallContext
	MethodCall(i int) IMethodCallContext
	DOT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	ConcatenatedString() IConcatenatedStringContext
	NIL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	LeftHandSide() ILeftHandSideContext
	ListLiteral() IListLiteralContext
	NegationExpression() INegationExpressionContext
	Expression() IExpressionContext
	ListAccess() IListAccessContext
	AnonimousFunctionDeclaration() IAnonimousFunctionDeclarationContext
	IncrementOrDecrementStatement() IIncrementOrDecrementStatementContext
	TypeConversion() ITypeConversionContext
	VarType() IVarTypeContext
	InterfaceTypeVerification() IInterfaceTypeVerificationContext
	DirectCreateInstance() IDirectCreateInstanceContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CreateObjectDeclaration() ICreateObjectDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateObjectDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateObjectDeclarationContext)
}

func (s *PrimaryExpressionContext) SliceDeclaration() ISliceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceDeclarationContext)
}

func (s *PrimaryExpressionContext) MapInitialization() IMapInitializationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapInitializationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapInitializationContext)
}

func (s *PrimaryExpressionContext) SliceOrArrayLiteral() ISliceOrArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceOrArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceOrArrayLiteralContext)
}

func (s *PrimaryExpressionContext) AllMethodCall() []IMethodCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodCallContext); ok {
			len++
		}
	}

	tst := make([]IMethodCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodCallContext); ok {
			tst[i] = t.(IMethodCallContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryExpressionContext) MethodCall(i int) IMethodCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *PrimaryExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(GoSugarParserDOT, 0)
}

func (s *PrimaryExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *PrimaryExpressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, 0)
}

func (s *PrimaryExpressionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoSugarParserAMPERSAND, 0)
}

func (s *PrimaryExpressionContext) ConcatenatedString() IConcatenatedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConcatenatedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConcatenatedStringContext)
}

func (s *PrimaryExpressionContext) NIL() antlr.TerminalNode {
	return s.GetToken(GoSugarParserNIL, 0)
}

func (s *PrimaryExpressionContext) STRING() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTRING, 0)
}

func (s *PrimaryExpressionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserNUMBER, 0)
}

func (s *PrimaryExpressionContext) LeftHandSide() ILeftHandSideContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *PrimaryExpressionContext) ListLiteral() IListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *PrimaryExpressionContext) NegationExpression() INegationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INegationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INegationExpressionContext)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) ListAccess() IListAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListAccessContext)
}

func (s *PrimaryExpressionContext) AnonimousFunctionDeclaration() IAnonimousFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonimousFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonimousFunctionDeclarationContext)
}

func (s *PrimaryExpressionContext) IncrementOrDecrementStatement() IIncrementOrDecrementStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncrementOrDecrementStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncrementOrDecrementStatementContext)
}

func (s *PrimaryExpressionContext) TypeConversion() ITypeConversionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConversionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConversionContext)
}

func (s *PrimaryExpressionContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *PrimaryExpressionContext) InterfaceTypeVerification() IInterfaceTypeVerificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeVerificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeVerificationContext)
}

func (s *PrimaryExpressionContext) DirectCreateInstance() IDirectCreateInstanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectCreateInstanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectCreateInstanceContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *GoSugarParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GoSugarParserRULE_primaryExpression)
	var _la int

	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(685)
			p.CreateObjectDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(686)
			p.SliceDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(687)
			p.MapInitialization()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(688)
			p.SliceOrArrayLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(689)
			p.MethodCall()
		}
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserDOT {
			{
				p.SetState(690)
				p.Match(GoSugarParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(691)
				p.MethodCall()
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserSTAR {
			{
				p.SetState(694)
				p.Match(GoSugarParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(697)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserAMPERSAND {
			{
				p.SetState(698)
				p.Match(GoSugarParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(701)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(702)
			p.ConcatenatedString()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(703)
			p.Match(GoSugarParserNIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(704)
			p.Match(GoSugarParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(705)
			p.Match(GoSugarParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(706)
			p.LeftHandSide()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(707)
			p.ListLiteral()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(708)
			p.NegationExpression()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(709)
			p.Match(GoSugarParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(710)
			p.Expression()
		}
		{
			p.SetState(711)
			p.Match(GoSugarParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(713)
			p.ListAccess()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(714)
			p.AnonimousFunctionDeclaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(715)
			p.IncrementOrDecrementStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(716)
			p.TypeConversion()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(717)
			p.VarType()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(718)
			p.InterfaceTypeVerification()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(719)
			p.DirectCreateInstance()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectCreateInstanceContext is an interface to support dynamic dispatch.
type IDirectCreateInstanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarType() IVarTypeContext
	AMPERSAND() antlr.TerminalNode
	AllMapKeyValue() []IMapKeyValueContext
	MapKeyValue(i int) IMapKeyValueContext

	// IsDirectCreateInstanceContext differentiates from other interfaces.
	IsDirectCreateInstanceContext()
}

type DirectCreateInstanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectCreateInstanceContext() *DirectCreateInstanceContext {
	var p = new(DirectCreateInstanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_directCreateInstance
	return p
}

func InitEmptyDirectCreateInstanceContext(p *DirectCreateInstanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_directCreateInstance
}

func (*DirectCreateInstanceContext) IsDirectCreateInstanceContext() {}

func NewDirectCreateInstanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectCreateInstanceContext {
	var p = new(DirectCreateInstanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_directCreateInstance

	return p
}

func (s *DirectCreateInstanceContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectCreateInstanceContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *DirectCreateInstanceContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoSugarParserAMPERSAND, 0)
}

func (s *DirectCreateInstanceContext) AllMapKeyValue() []IMapKeyValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapKeyValueContext); ok {
			len++
		}
	}

	tst := make([]IMapKeyValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapKeyValueContext); ok {
			tst[i] = t.(IMapKeyValueContext)
			i++
		}
	}

	return tst
}

func (s *DirectCreateInstanceContext) MapKeyValue(i int) IMapKeyValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapKeyValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapKeyValueContext)
}

func (s *DirectCreateInstanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectCreateInstanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectCreateInstanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterDirectCreateInstance(s)
	}
}

func (s *DirectCreateInstanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitDirectCreateInstance(s)
	}
}

func (p *GoSugarParser) DirectCreateInstance() (localctx IDirectCreateInstanceContext) {
	localctx = NewDirectCreateInstanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GoSugarParserRULE_directCreateInstance)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(723)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(722)
			p.Match(GoSugarParserAMPERSAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(725)
		p.VarType()
	}
	{
		p.SetState(726)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserIDENTIFIER || _la == GoSugarParserSTRING {
		{
			p.SetState(727)
			p.MapKeyValue()
		}
		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(728)
					p.Match(GoSugarParserT__12)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(729)
					p.MapKeyValue()
				}

			}
			p.SetState(734)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserT__12 {
			{
				p.SetState(735)
				p.Match(GoSugarParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(740)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapKeyValueContext is an interface to support dynamic dispatch.
type IMapKeyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	STRING() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsMapKeyValueContext differentiates from other interfaces.
	IsMapKeyValueContext()
}

type MapKeyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapKeyValueContext() *MapKeyValueContext {
	var p = new(MapKeyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_mapKeyValue
	return p
}

func InitEmptyMapKeyValueContext(p *MapKeyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_mapKeyValue
}

func (*MapKeyValueContext) IsMapKeyValueContext() {}

func NewMapKeyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapKeyValueContext {
	var p = new(MapKeyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_mapKeyValue

	return p
}

func (s *MapKeyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *MapKeyValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapKeyValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTRING, 0)
}

func (s *MapKeyValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *MapKeyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapKeyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapKeyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterMapKeyValue(s)
	}
}

func (s *MapKeyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitMapKeyValue(s)
	}
}

func (p *GoSugarParser) MapKeyValue() (localctx IMapKeyValueContext) {
	localctx = NewMapKeyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GoSugarParserRULE_mapKeyValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoSugarParserIDENTIFIER || _la == GoSugarParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(743)
		p.Match(GoSugarParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(744)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapKeyValue() []IMapKeyValueContext
	MapKeyValue(i int) IMapKeyValueContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	VarType() IVarTypeContext
	NUMBER() antlr.TerminalNode

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_listLiteral
	return p
}

func InitEmptyListLiteralContext(p *ListLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_listLiteral
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) AllMapKeyValue() []IMapKeyValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapKeyValueContext); ok {
			len++
		}
	}

	tst := make([]IMapKeyValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapKeyValueContext); ok {
			tst[i] = t.(IMapKeyValueContext)
			i++
		}
	}

	return tst
}

func (s *ListLiteralContext) MapKeyValue(i int) IMapKeyValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapKeyValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapKeyValueContext)
}

func (s *ListLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListLiteralContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ListLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserNUMBER, 0)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterListLiteral(s)
	}
}

func (s *ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitListLiteral(s)
	}
}

func (p *GoSugarParser) ListLiteral() (localctx IListLiteralContext) {
	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GoSugarParserRULE_listLiteral)
	var _la int

	var _alt int

	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(746)
			p.Match(GoSugarParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserIDENTIFIER || _la == GoSugarParserSTRING {
			{
				p.SetState(747)
				p.MapKeyValue()
			}
			p.SetState(752)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(748)
						p.Match(GoSugarParserT__12)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(749)
						p.MapKeyValue()
					}

				}
				p.SetState(754)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(756)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GoSugarParserT__12 {
				{
					p.SetState(755)
					p.Match(GoSugarParserT__12)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(760)
			p.Match(GoSugarParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)
			p.Match(GoSugarParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
			{
				p.SetState(762)
				p.Expression()
			}
			p.SetState(767)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(763)
						p.Match(GoSugarParserT__12)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(764)
						p.Expression()
					}

				}
				p.SetState(769)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(771)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GoSugarParserT__12 {
				{
					p.SetState(770)
					p.Match(GoSugarParserT__12)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(775)
			p.Match(GoSugarParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(776)
			p.VarType()
		}
		{
			p.SetState(777)
			p.Match(GoSugarParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
			{
				p.SetState(778)
				p.Expression()
			}
			p.SetState(783)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(779)
						p.Match(GoSugarParserT__12)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(780)
						p.Expression()
					}

				}
				p.SetState(785)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(787)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GoSugarParserT__12 {
				{
					p.SetState(786)
					p.Match(GoSugarParserT__12)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(791)
			p.Match(GoSugarParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(793)
			p.VarType()
		}
		{
			p.SetState(794)
			p.Match(GoSugarParserT__13)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserNUMBER {
			{
				p.SetState(795)
				p.Match(GoSugarParserNUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(798)
			p.Match(GoSugarParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(799)
			p.Match(GoSugarParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
			{
				p.SetState(800)
				p.Expression()
			}
			p.SetState(805)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(801)
						p.Match(GoSugarParserT__12)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(802)
						p.Expression()
					}

				}
				p.SetState(807)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(809)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GoSugarParserT__12 {
				{
					p.SetState(808)
					p.Match(GoSugarParserT__12)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(813)
			p.Match(GoSugarParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(815)
			p.VarType()
		}
		{
			p.SetState(816)
			p.Match(GoSugarParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorExpressionContext is an interface to support dynamic dispatch.
type IOperatorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	STAR() antlr.TerminalNode
	ComparisonOperator() IComparisonOperatorContext

	// IsOperatorExpressionContext differentiates from other interfaces.
	IsOperatorExpressionContext()
}

type OperatorExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorExpressionContext() *OperatorExpressionContext {
	var p = new(OperatorExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_operatorExpression
	return p
}

func InitEmptyOperatorExpressionContext(p *OperatorExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_operatorExpression
}

func (*OperatorExpressionContext) IsOperatorExpressionContext() {}

func NewOperatorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorExpressionContext {
	var p = new(OperatorExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_operatorExpression

	return p
}

func (s *OperatorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *OperatorExpressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, 0)
}

func (s *OperatorExpressionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *OperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterOperatorExpression(s)
	}
}

func (s *OperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitOperatorExpression(s)
	}
}

func (p *GoSugarParser) OperatorExpression() (localctx IOperatorExpressionContext) {
	localctx = NewOperatorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GoSugarParserRULE_operatorExpression)
	var _la int

	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoSugarParserT__46, GoSugarParserT__47, GoSugarParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(820)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9222949824389709824) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(821)
			p.PrimaryExpression()
		}

	case GoSugarParserT__44, GoSugarParserT__48:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GoSugarParserT__44 || _la == GoSugarParserT__48) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(823)
			p.PrimaryExpression()
		}

	case GoSugarParserT__36, GoSugarParserT__37, GoSugarParserT__38, GoSugarParserT__39, GoSugarParserT__40, GoSugarParserT__41, GoSugarParserT__42, GoSugarParserT__43:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(824)
			p.ComparisonOperator()
		}
		{
			p.SetState(825)
			p.PrimaryExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	ComparisonOperator() IComparisonOperatorContext
	Comparison() IComparisonContext

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_comparison
	return p
}

func InitEmptyComparisonContext(p *ComparisonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_comparison
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) Comparison() IComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *GoSugarParser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, GoSugarParserRULE_comparison)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.PrimaryExpression()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35046933135360) != 0 {
		{
			p.SetState(830)
			p.ComparisonOperator()
		}
		{
			p.SetState(831)
			p.Comparison()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnOperationContext is an interface to support dynamic dispatch.
type IReturnOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArgumentList() IArgumentListContext

	// IsReturnOperationContext differentiates from other interfaces.
	IsReturnOperationContext()
}

type ReturnOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnOperationContext() *ReturnOperationContext {
	var p = new(ReturnOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnOperation
	return p
}

func InitEmptyReturnOperationContext(p *ReturnOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_returnOperation
}

func (*ReturnOperationContext) IsReturnOperationContext() {}

func NewReturnOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnOperationContext {
	var p = new(ReturnOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_returnOperation

	return p
}

func (s *ReturnOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnOperationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ReturnOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterReturnOperation(s)
	}
}

func (s *ReturnOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitReturnOperation(s)
	}
}

func (p *GoSugarParser) ReturnOperation() (localctx IReturnOperationContext) {
	localctx = NewReturnOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GoSugarParserRULE_returnOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(835)
		p.Match(GoSugarParserT__49)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(837)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(836)
			p.ArgumentList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueOperationContext is an interface to support dynamic dispatch.
type IContinueOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsContinueOperationContext differentiates from other interfaces.
	IsContinueOperationContext()
}

type ContinueOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueOperationContext() *ContinueOperationContext {
	var p = new(ContinueOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_continueOperation
	return p
}

func InitEmptyContinueOperationContext(p *ContinueOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_continueOperation
}

func (*ContinueOperationContext) IsContinueOperationContext() {}

func NewContinueOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueOperationContext {
	var p = new(ContinueOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_continueOperation

	return p
}

func (s *ContinueOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueOperationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *ContinueOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterContinueOperation(s)
	}
}

func (s *ContinueOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitContinueOperation(s)
	}
}

func (p *GoSugarParser) ContinueOperation() (localctx IContinueOperationContext) {
	localctx = NewContinueOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GoSugarParserRULE_continueOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.Match(GoSugarParserT__50)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(840)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakOperationContext is an interface to support dynamic dispatch.
type IBreakOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsBreakOperationContext differentiates from other interfaces.
	IsBreakOperationContext()
}

type BreakOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakOperationContext() *BreakOperationContext {
	var p = new(BreakOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_breakOperation
	return p
}

func InitEmptyBreakOperationContext(p *BreakOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_breakOperation
}

func (*BreakOperationContext) IsBreakOperationContext() {}

func NewBreakOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakOperationContext {
	var p = new(BreakOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_breakOperation

	return p
}

func (s *BreakOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakOperationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *BreakOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterBreakOperation(s)
	}
}

func (s *BreakOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitBreakOperation(s)
	}
}

func (p *GoSugarParser) BreakOperation() (localctx IBreakOperationContext) {
	localctx = NewBreakOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GoSugarParserRULE_breakOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(843)
		p.Match(GoSugarParserT__51)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(844)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarValueContext is an interface to support dynamic dispatch.
type IVarValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ListLiteral() IListLiteralContext
	Expression() IExpressionContext
	MapInitialization() IMapInitializationContext

	// IsVarValueContext differentiates from other interfaces.
	IsVarValueContext()
}

type VarValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarValueContext() *VarValueContext {
	var p = new(VarValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_varValue
	return p
}

func InitEmptyVarValueContext(p *VarValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_varValue
}

func (*VarValueContext) IsVarValueContext() {}

func NewVarValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarValueContext {
	var p = new(VarValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_varValue

	return p
}

func (s *VarValueContext) GetParser() antlr.Parser { return s.parser }

func (s *VarValueContext) ListLiteral() IListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *VarValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VarValueContext) MapInitialization() IMapInitializationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapInitializationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapInitializationContext)
}

func (s *VarValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterVarValue(s)
	}
}

func (s *VarValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitVarValue(s)
	}
}

func (p *GoSugarParser) VarValue() (localctx IVarValueContext) {
	localctx = NewVarValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GoSugarParserRULE_varValue)
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(847)
			p.ListLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(848)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(849)
			p.MapInitialization()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarStatementContext is an interface to support dynamic dispatch.
type IVarStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	VarType() IVarTypeContext
	AssignmentOperator() IAssignmentOperatorContext
	VarValue() IVarValueContext

	// IsVarStatementContext differentiates from other interfaces.
	IsVarStatementContext()
}

type VarStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarStatementContext() *VarStatementContext {
	var p = new(VarStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_varStatement
	return p
}

func InitEmptyVarStatementContext(p *VarStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_varStatement
}

func (*VarStatementContext) IsVarStatementContext() {}

func NewVarStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarStatementContext {
	var p = new(VarStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_varStatement

	return p
}

func (s *VarStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VarStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *VarStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *VarStatementContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *VarStatementContext) VarValue() IVarValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarValueContext)
}

func (s *VarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterVarStatement(s)
	}
}

func (s *VarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitVarStatement(s)
	}
}

func (p *GoSugarParser) VarStatement() (localctx IVarStatementContext) {
	localctx = NewVarStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GoSugarParserRULE_varStatement)
	var _la int

	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.Match(GoSugarParserT__52)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(853)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(854)
			p.VarType()
		}
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&137405399040) != 0 {
			{
				p.SetState(855)
				p.AssignmentOperator()
			}
			{
				p.SetState(856)
				p.VarValue()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(860)
			p.Match(GoSugarParserT__52)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(861)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(862)
			p.AssignmentOperator()
		}
		{
			p.SetState(863)
			p.VarValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comparison() IComparisonContext
	Block() IBlockContext
	Assignment() IAssignmentContext
	ElseStatement() IElseStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Comparison() IComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *IfStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStatementContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *IfStatementContext) ElseStatement() IElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *GoSugarParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GoSugarParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(GoSugarParserT__53)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(871)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(868)
			p.Assignment()
		}
		{
			p.SetState(869)
			p.Match(GoSugarParserT__54)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(873)
		p.Comparison()
	}
	{
		p.SetState(874)
		p.Block()
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(875)
			p.ElseStatement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseStatementContext is an interface to support dynamic dispatch.
type IElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	Block() IBlockContext

	// IsElseStatementContext differentiates from other interfaces.
	IsElseStatementContext()
}

type ElseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseStatementContext() *ElseStatementContext {
	var p = new(ElseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_elseStatement
	return p
}

func InitEmptyElseStatementContext(p *ElseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_elseStatement
}

func (*ElseStatementContext) IsElseStatementContext() {}

func NewElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseStatementContext {
	var p = new(ElseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_elseStatement

	return p
}

func (s *ElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ElseStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterElseStatement(s)
	}
}

func (s *ElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitElseStatement(s)
	}
}

func (p *GoSugarParser) ElseStatement() (localctx IElseStatementContext) {
	localctx = NewElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GoSugarParserRULE_elseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(GoSugarParserT__55)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GoSugarParserT__53:
		{
			p.SetState(879)
			p.IfStatement()
		}

	case GoSugarParserT__1:
		{
			p.SetState(880)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIncrementOrDecrementStatementContext is an interface to support dynamic dispatch.
type IIncrementOrDecrementStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode

	// IsIncrementOrDecrementStatementContext differentiates from other interfaces.
	IsIncrementOrDecrementStatementContext()
}

type IncrementOrDecrementStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncrementOrDecrementStatementContext() *IncrementOrDecrementStatementContext {
	var p = new(IncrementOrDecrementStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_incrementOrDecrementStatement
	return p
}

func InitEmptyIncrementOrDecrementStatementContext(p *IncrementOrDecrementStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_incrementOrDecrementStatement
}

func (*IncrementOrDecrementStatementContext) IsIncrementOrDecrementStatementContext() {}

func NewIncrementOrDecrementStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncrementOrDecrementStatementContext {
	var p = new(IncrementOrDecrementStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_incrementOrDecrementStatement

	return p
}

func (s *IncrementOrDecrementStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IncrementOrDecrementStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *IncrementOrDecrementStatementContext) STAR() antlr.TerminalNode {
	return s.GetToken(GoSugarParserSTAR, 0)
}

func (s *IncrementOrDecrementStatementContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GoSugarParserAMPERSAND, 0)
}

func (s *IncrementOrDecrementStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncrementOrDecrementStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncrementOrDecrementStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterIncrementOrDecrementStatement(s)
	}
}

func (s *IncrementOrDecrementStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitIncrementOrDecrementStatement(s)
	}
}

func (p *GoSugarParser) IncrementOrDecrementStatement() (localctx IIncrementOrDecrementStatementContext) {
	localctx = NewIncrementOrDecrementStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GoSugarParserRULE_incrementOrDecrementStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserSTAR {
		{
			p.SetState(883)
			p.Match(GoSugarParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserAMPERSAND {
		{
			p.SetState(886)
			p.Match(GoSugarParserAMPERSAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(889)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(890)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GoSugarParserT__56 || _la == GoSugarParserT__57) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	ClassicForLoop() IClassicForLoopContext
	RangeForLoop() IRangeForLoopContext
	ConditionForLoop() IConditionForLoopContext
	InfiniteForLoop() IInfiniteForLoopContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStatementContext) ClassicForLoop() IClassicForLoopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassicForLoopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassicForLoopContext)
}

func (s *ForStatementContext) RangeForLoop() IRangeForLoopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeForLoopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeForLoopContext)
}

func (s *ForStatementContext) ConditionForLoop() IConditionForLoopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionForLoopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionForLoopContext)
}

func (s *ForStatementContext) InfiniteForLoop() IInfiniteForLoopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfiniteForLoopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfiniteForLoopContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *GoSugarParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GoSugarParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(892)
		p.Match(GoSugarParserT__58)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(893)
			p.ClassicForLoop()
		}

	case 2:
		{
			p.SetState(894)
			p.RangeForLoop()
		}

	case 3:
		{
			p.SetState(895)
			p.ConditionForLoop()
		}

	case 4:
		{
			p.SetState(896)
			p.InfiniteForLoop()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(899)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassicForLoopContext is an interface to support dynamic dispatch.
type IClassicForLoopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleStatement() []ISimpleStatementContext
	SimpleStatement(i int) ISimpleStatementContext
	Expression() IExpressionContext

	// IsClassicForLoopContext differentiates from other interfaces.
	IsClassicForLoopContext()
}

type ClassicForLoopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassicForLoopContext() *ClassicForLoopContext {
	var p = new(ClassicForLoopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classicForLoop
	return p
}

func InitEmptyClassicForLoopContext(p *ClassicForLoopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_classicForLoop
}

func (*ClassicForLoopContext) IsClassicForLoopContext() {}

func NewClassicForLoopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassicForLoopContext {
	var p = new(ClassicForLoopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_classicForLoop

	return p
}

func (s *ClassicForLoopContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassicForLoopContext) AllSimpleStatement() []ISimpleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISimpleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleStatementContext); ok {
			tst[i] = t.(ISimpleStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassicForLoopContext) SimpleStatement(i int) ISimpleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *ClassicForLoopContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassicForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassicForLoopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassicForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterClassicForLoop(s)
	}
}

func (s *ClassicForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitClassicForLoop(s)
	}
}

func (p *GoSugarParser) ClassicForLoop() (localctx IClassicForLoopContext) {
	localctx = NewClassicForLoopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GoSugarParserRULE_classicForLoop)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
		{
			p.SetState(901)
			p.SimpleStatement()
		}

	}
	{
		p.SetState(904)
		p.Match(GoSugarParserT__54)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
		{
			p.SetState(905)
			p.Expression()
		}

	}
	{
		p.SetState(908)
		p.Match(GoSugarParserT__54)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(909)
			p.SimpleStatement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeForLoopContext is an interface to support dynamic dispatch.
type IRangeForLoopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ExpressionList() IExpressionListContext

	// IsRangeForLoopContext differentiates from other interfaces.
	IsRangeForLoopContext()
}

type RangeForLoopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeForLoopContext() *RangeForLoopContext {
	var p = new(RangeForLoopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_rangeForLoop
	return p
}

func InitEmptyRangeForLoopContext(p *RangeForLoopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_rangeForLoop
}

func (*RangeForLoopContext) IsRangeForLoopContext() {}

func NewRangeForLoopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeForLoopContext {
	var p = new(RangeForLoopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_rangeForLoop

	return p
}

func (s *RangeForLoopContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeForLoopContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeForLoopContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RangeForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeForLoopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterRangeForLoop(s)
	}
}

func (s *RangeForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitRangeForLoop(s)
	}
}

func (p *GoSugarParser) RangeForLoop() (localctx IRangeForLoopContext) {
	localctx = NewRangeForLoopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GoSugarParserRULE_rangeForLoop)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223301668102123500) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&411) != 0) {
		{
			p.SetState(912)
			p.ExpressionList()
		}
		{
			p.SetState(913)
			p.Match(GoSugarParserT__25)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(917)
		p.Match(GoSugarParserT__59)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(918)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionForLoopContext is an interface to support dynamic dispatch.
type IConditionForLoopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsConditionForLoopContext differentiates from other interfaces.
	IsConditionForLoopContext()
}

type ConditionForLoopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionForLoopContext() *ConditionForLoopContext {
	var p = new(ConditionForLoopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_conditionForLoop
	return p
}

func InitEmptyConditionForLoopContext(p *ConditionForLoopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_conditionForLoop
}

func (*ConditionForLoopContext) IsConditionForLoopContext() {}

func NewConditionForLoopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionForLoopContext {
	var p = new(ConditionForLoopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_conditionForLoop

	return p
}

func (s *ConditionForLoopContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionForLoopContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionForLoopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterConditionForLoop(s)
	}
}

func (s *ConditionForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitConditionForLoop(s)
	}
}

func (p *GoSugarParser) ConditionForLoop() (localctx IConditionForLoopContext) {
	localctx = NewConditionForLoopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GoSugarParserRULE_conditionForLoop)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInfiniteForLoopContext is an interface to support dynamic dispatch.
type IInfiniteForLoopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInfiniteForLoopContext differentiates from other interfaces.
	IsInfiniteForLoopContext()
}

type InfiniteForLoopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfiniteForLoopContext() *InfiniteForLoopContext {
	var p = new(InfiniteForLoopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_infiniteForLoop
	return p
}

func InitEmptyInfiniteForLoopContext(p *InfiniteForLoopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_infiniteForLoop
}

func (*InfiniteForLoopContext) IsInfiniteForLoopContext() {}

func NewInfiniteForLoopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfiniteForLoopContext {
	var p = new(InfiniteForLoopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_infiniteForLoop

	return p
}

func (s *InfiniteForLoopContext) GetParser() antlr.Parser { return s.parser }
func (s *InfiniteForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfiniteForLoopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfiniteForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterInfiniteForLoop(s)
	}
}

func (s *InfiniteForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitInfiniteForLoop(s)
	}
}

func (p *GoSugarParser) InfiniteForLoop() (localctx IInfiniteForLoopContext) {
	localctx = NewInfiniteForLoopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GoSugarParserRULE_infiniteForLoop)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment() IAssignmentContext
	Expression() IExpressionContext
	IncrementOrDecrementStatement() IIncrementOrDecrementStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *SimpleStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleStatementContext) IncrementOrDecrementStatement() IIncrementOrDecrementStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncrementOrDecrementStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncrementOrDecrementStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (p *GoSugarParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GoSugarParserRULE_simpleStatement)
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(924)
			p.Assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(925)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(926)
			p.IncrementOrDecrementStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *GoSugarParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GoSugarParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.Expression()
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GoSugarParserT__12 {
		{
			p.SetState(930)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(931)
			p.Expression()
		}

		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapInitializationContext is an interface to support dynamic dispatch.
type IMapInitializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarType() IVarTypeContext
	AllMapKeyValue() []IMapKeyValueContext
	MapKeyValue(i int) IMapKeyValueContext

	// IsMapInitializationContext differentiates from other interfaces.
	IsMapInitializationContext()
}

type MapInitializationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapInitializationContext() *MapInitializationContext {
	var p = new(MapInitializationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_mapInitialization
	return p
}

func InitEmptyMapInitializationContext(p *MapInitializationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_mapInitialization
}

func (*MapInitializationContext) IsMapInitializationContext() {}

func NewMapInitializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapInitializationContext {
	var p = new(MapInitializationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_mapInitialization

	return p
}

func (s *MapInitializationContext) GetParser() antlr.Parser { return s.parser }

func (s *MapInitializationContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *MapInitializationContext) AllMapKeyValue() []IMapKeyValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapKeyValueContext); ok {
			len++
		}
	}

	tst := make([]IMapKeyValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapKeyValueContext); ok {
			tst[i] = t.(IMapKeyValueContext)
			i++
		}
	}

	return tst
}

func (s *MapInitializationContext) MapKeyValue(i int) IMapKeyValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapKeyValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapKeyValueContext)
}

func (s *MapInitializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapInitializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapInitializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterMapInitialization(s)
	}
}

func (s *MapInitializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitMapInitialization(s)
	}
}

func (p *GoSugarParser) MapInitialization() (localctx IMapInitializationContext) {
	localctx = NewMapInitializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GoSugarParserRULE_mapInitialization)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.VarType()
	}
	{
		p.SetState(938)
		p.Match(GoSugarParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserIDENTIFIER || _la == GoSugarParserSTRING {
		{
			p.SetState(939)
			p.MapKeyValue()
		}
		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(940)
					p.Match(GoSugarParserT__12)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(941)
					p.MapKeyValue()
				}

			}
			p.SetState(946)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GoSugarParserT__12 {
			{
				p.SetState(947)
				p.Match(GoSugarParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(952)
		p.Match(GoSugarParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeachStatementContext is an interface to support dynamic dispatch.
type IForeachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	Block() IBlockContext

	// IsForeachStatementContext differentiates from other interfaces.
	IsForeachStatementContext()
}

type ForeachStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachStatementContext() *ForeachStatementContext {
	var p = new(ForeachStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_foreachStatement
	return p
}

func InitEmptyForeachStatementContext(p *ForeachStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_foreachStatement
}

func (*ForeachStatementContext) IsForeachStatementContext() {}

func NewForeachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachStatementContext {
	var p = new(ForeachStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_foreachStatement

	return p
}

func (s *ForeachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForeachStatementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(GoSugarParserIDENTIFIER)
}

func (s *ForeachStatementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, i)
}

func (s *ForeachStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForeachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterForeachStatement(s)
	}
}

func (s *ForeachStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitForeachStatement(s)
	}
}

func (p *GoSugarParser) ForeachStatement() (localctx IForeachStatementContext) {
	localctx = NewForeachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GoSugarParserRULE_foreachStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Match(GoSugarParserT__60)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(955)
		p.Expression()
	}
	{
		p.SetState(956)
		p.Match(GoSugarParserT__6)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(957)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GoSugarParserT__12 {
		{
			p.SetState(958)
			p.Match(GoSugarParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Match(GoSugarParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(962)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeConversionContext is an interface to support dynamic dispatch.
type ITypeConversionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsTypeConversionContext differentiates from other interfaces.
	IsTypeConversionContext()
}

type TypeConversionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConversionContext() *TypeConversionContext {
	var p = new(TypeConversionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_typeConversion
	return p
}

func InitEmptyTypeConversionContext(p *TypeConversionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GoSugarParserRULE_typeConversion
}

func (*TypeConversionContext) IsTypeConversionContext() {}

func NewTypeConversionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConversionContext {
	var p = new(TypeConversionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GoSugarParserRULE_typeConversion

	return p
}

func (s *TypeConversionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConversionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GoSugarParserIDENTIFIER, 0)
}

func (s *TypeConversionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeConversionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConversionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConversionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.EnterTypeConversion(s)
	}
}

func (s *TypeConversionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GoSugarListener); ok {
		listenerT.ExitTypeConversion(s)
	}
}

func (p *GoSugarParser) TypeConversion() (localctx ITypeConversionContext) {
	localctx = NewTypeConversionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GoSugarParserRULE_typeConversion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(964)
		p.Match(GoSugarParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(965)
		p.Match(GoSugarParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(966)
		p.Expression()
	}
	{
		p.SetState(967)
		p.Match(GoSugarParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
